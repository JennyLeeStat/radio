
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <title>keras.engine.training &#8212; RadIO 0.1.0 documentation</title>
    <link rel="stylesheet" href="../../../_static/classic.css" type="text/css" />
    <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../../../',
        VERSION:     '0.1.0',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true,
        SOURCELINK_SUFFIX: '.txt'
      };
    </script>
    <script type="text/javascript" src="../../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../../_static/doctools.js"></script>
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" /> 
  </head>
  <body>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="nav-item nav-item-0"><a href="../../../index.html">RadIO 0.1.0 documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="../../index.html" accesskey="U">Module code</a> &#187;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <h1>Source code for keras.engine.training</h1><div class="highlight"><pre>
<span></span><span class="c1"># -*- coding: utf-8 -*-</span>
<span class="kn">from</span> <span class="nn">__future__</span> <span class="k">import</span> <span class="n">print_function</span>
<span class="kn">from</span> <span class="nn">__future__</span> <span class="k">import</span> <span class="n">absolute_import</span>

<span class="kn">import</span> <span class="nn">warnings</span>
<span class="kn">import</span> <span class="nn">copy</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">six</span>

<span class="kn">from</span> <span class="nn">keras.utils</span> <span class="k">import</span> <span class="n">Sequence</span>
<span class="kn">from</span> <span class="nn">keras.utils</span> <span class="k">import</span> <span class="n">GeneratorEnqueuer</span>
<span class="kn">from</span> <span class="nn">keras.utils</span> <span class="k">import</span> <span class="n">OrderedEnqueuer</span>

<span class="k">try</span><span class="p">:</span>
    <span class="kn">import</span> <span class="nn">queue</span>
<span class="k">except</span> <span class="ne">ImportError</span><span class="p">:</span>
    <span class="kn">import</span> <span class="nn">Queue</span> <span class="k">as</span> <span class="nn">queue</span>

<span class="kn">from</span> <span class="nn">.topology</span> <span class="k">import</span> <span class="n">Container</span>
<span class="kn">from</span> <span class="nn">..</span> <span class="k">import</span> <span class="n">backend</span> <span class="k">as</span> <span class="n">K</span>
<span class="kn">from</span> <span class="nn">..</span> <span class="k">import</span> <span class="n">optimizers</span>
<span class="kn">from</span> <span class="nn">..</span> <span class="k">import</span> <span class="n">losses</span>
<span class="kn">from</span> <span class="nn">..</span> <span class="k">import</span> <span class="n">metrics</span> <span class="k">as</span> <span class="n">metrics_module</span>
<span class="kn">from</span> <span class="nn">..utils.generic_utils</span> <span class="k">import</span> <span class="n">Progbar</span>
<span class="kn">from</span> <span class="nn">..</span> <span class="k">import</span> <span class="n">callbacks</span> <span class="k">as</span> <span class="n">cbks</span>
<span class="kn">from</span> <span class="nn">..legacy</span> <span class="k">import</span> <span class="n">interfaces</span>


<span class="k">def</span> <span class="nf">_standardize_input_data</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">names</span><span class="p">,</span> <span class="n">shapes</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                            <span class="n">check_batch_axis</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                            <span class="n">exception_prefix</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Normalizes inputs and targets provided by users.</span>

<span class="sd">    Users may pass data as a list of arrays, dictionary of arrays,</span>
<span class="sd">    or as a single array. We normalize this to an ordered list of</span>
<span class="sd">    arrays (same order as `names`), while checking that the provided</span>
<span class="sd">    arrays have shapes that match the network&#39;s expectations.</span>

<span class="sd">    # Arguments</span>
<span class="sd">        data: User-provided input data (polymorphic).</span>
<span class="sd">        names: List of expected array names.</span>
<span class="sd">        shapes: Optional list of expected array shapes.</span>
<span class="sd">        check_batch_axis: Boolean; whether to check that</span>
<span class="sd">            the batch axis of the arrays matches the expected</span>
<span class="sd">            value found in `shapes`.</span>
<span class="sd">        exception_prefix: String prefix used for exception formatting.</span>

<span class="sd">    # Returns</span>
<span class="sd">        List of standardized input arrays (one array per model input).</span>

<span class="sd">    # Raises</span>
<span class="sd">        ValueError: in case of improperly formatted user-provided data.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">names</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">data</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="s1">&#39;__len__&#39;</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Error when checking model &#39;</span> <span class="o">+</span>
                             <span class="n">exception_prefix</span> <span class="o">+</span> <span class="s1">&#39;: &#39;</span>
                             <span class="s1">&#39;expected no data, but got:&#39;</span><span class="p">,</span> <span class="n">data</span><span class="p">)</span>
        <span class="k">return</span> <span class="p">[]</span>
    <span class="k">if</span> <span class="n">data</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">return</span> <span class="p">[</span><span class="kc">None</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">names</span><span class="p">))]</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
        <span class="n">arrays</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">names</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">name</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">data</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;No data provided for &quot;&#39;</span> <span class="o">+</span>
                                 <span class="n">name</span> <span class="o">+</span> <span class="s1">&#39;&quot;. Need data for each key in: &#39;</span> <span class="o">+</span>
                                 <span class="nb">str</span><span class="p">(</span><span class="n">names</span><span class="p">))</span>
            <span class="n">arrays</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="n">name</span><span class="p">])</span>
    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">names</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">data</span> <span class="ow">and</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="s1">&#39;shape&#39;</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Error when checking model &#39;</span> <span class="o">+</span>
                                 <span class="n">exception_prefix</span> <span class="o">+</span>
                                 <span class="s1">&#39;: the list of Numpy arrays &#39;</span>
                                 <span class="s1">&#39;that you are passing to your model &#39;</span>
                                 <span class="s1">&#39;is not the size the model expected. &#39;</span>
                                 <span class="s1">&#39;Expected to see &#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">names</span><span class="p">))</span> <span class="o">+</span>
                                 <span class="s1">&#39; array(s), but instead got &#39;</span>
                                 <span class="s1">&#39;the following list of &#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">))</span> <span class="o">+</span>
                                 <span class="s1">&#39; arrays: &#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">data</span><span class="p">)[:</span><span class="mi">200</span><span class="p">]</span> <span class="o">+</span>
                                 <span class="s1">&#39;...&#39;</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">names</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="n">data</span> <span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">data</span><span class="p">)]</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                        <span class="s1">&#39;Error when checking model &#39;</span> <span class="o">+</span>
                        <span class="n">exception_prefix</span> <span class="o">+</span>
                        <span class="s1">&#39;: you are passing a list as &#39;</span>
                        <span class="s1">&#39;input to your model, &#39;</span>
                        <span class="s1">&#39;but the model expects &#39;</span>
                        <span class="s1">&#39;a list of &#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">names</span><span class="p">))</span> <span class="o">+</span>
                        <span class="s1">&#39; Numpy arrays instead. &#39;</span>
                        <span class="s1">&#39;The list you passed was: &#39;</span> <span class="o">+</span>
                        <span class="nb">str</span><span class="p">(</span><span class="n">data</span><span class="p">)[:</span><span class="mi">200</span><span class="p">])</span>
        <span class="n">arrays</span> <span class="o">=</span> <span class="n">data</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="s1">&#39;shape&#39;</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;Error when checking model &#39;</span> <span class="o">+</span>
                            <span class="n">exception_prefix</span> <span class="o">+</span>
                            <span class="s1">&#39;: data should be a Numpy array, &#39;</span>
                            <span class="s1">&#39;or list/dict of Numpy arrays. &#39;</span>
                            <span class="s1">&#39;Found: &#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">data</span><span class="p">)[:</span><span class="mi">200</span><span class="p">]</span> <span class="o">+</span> <span class="s1">&#39;...&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">names</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="c1"># Case: model expects multiple inputs but only received</span>
            <span class="c1"># a single Numpy array.</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;The model expects &#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">names</span><span class="p">))</span> <span class="o">+</span> <span class="s1">&#39; &#39;</span> <span class="o">+</span>
                             <span class="n">exception_prefix</span> <span class="o">+</span>
                             <span class="s1">&#39; arrays, but only received one array. &#39;</span>
                             <span class="s1">&#39;Found: array with shape &#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">))</span>
        <span class="n">arrays</span> <span class="o">=</span> <span class="p">[</span><span class="n">data</span><span class="p">]</span>

    <span class="c1"># Make arrays at least 2D.</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">names</span><span class="p">)):</span>
        <span class="n">array</span> <span class="o">=</span> <span class="n">arrays</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">array</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">array</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">expand_dims</span><span class="p">(</span><span class="n">array</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
            <span class="n">arrays</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">array</span>

    <span class="c1"># Check shapes compatibility.</span>
    <span class="k">if</span> <span class="n">shapes</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">names</span><span class="p">)):</span>
            <span class="k">if</span> <span class="n">shapes</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">continue</span>
            <span class="n">array</span> <span class="o">=</span> <span class="n">arrays</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">array</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">shapes</span><span class="p">[</span><span class="n">i</span><span class="p">]):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Error when checking &#39;</span> <span class="o">+</span> <span class="n">exception_prefix</span> <span class="o">+</span>
                                 <span class="s1">&#39;: expected &#39;</span> <span class="o">+</span> <span class="n">names</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span>
                                 <span class="s1">&#39; to have &#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">shapes</span><span class="p">[</span><span class="n">i</span><span class="p">]))</span> <span class="o">+</span>
                                 <span class="s1">&#39; dimensions, but got array with shape &#39;</span> <span class="o">+</span>
                                 <span class="nb">str</span><span class="p">(</span><span class="n">array</span><span class="o">.</span><span class="n">shape</span><span class="p">))</span>
            <span class="k">for</span> <span class="n">j</span><span class="p">,</span> <span class="p">(</span><span class="n">dim</span><span class="p">,</span> <span class="n">ref_dim</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">array</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">shapes</span><span class="p">[</span><span class="n">i</span><span class="p">])):</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">j</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">check_batch_axis</span><span class="p">:</span>
                    <span class="c1"># skip the first axis</span>
                    <span class="k">continue</span>
                <span class="k">if</span> <span class="n">ref_dim</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">ref_dim</span> <span class="o">!=</span> <span class="n">dim</span><span class="p">:</span>
                        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                            <span class="s1">&#39;Error when checking &#39;</span> <span class="o">+</span> <span class="n">exception_prefix</span> <span class="o">+</span>
                            <span class="s1">&#39;: expected &#39;</span> <span class="o">+</span> <span class="n">names</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span>
                            <span class="s1">&#39; to have shape &#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">shapes</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="o">+</span>
                            <span class="s1">&#39; but got array with shape &#39;</span> <span class="o">+</span>
                            <span class="nb">str</span><span class="p">(</span><span class="n">array</span><span class="o">.</span><span class="n">shape</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">arrays</span>


<span class="k">def</span> <span class="nf">_standardize_sample_or_class_weights</span><span class="p">(</span><span class="n">x_weight</span><span class="p">,</span> <span class="n">output_names</span><span class="p">,</span> <span class="n">weight_type</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Maps `sample_weight` or `class_weight` to model outputs.</span>

<span class="sd">    # Arguments</span>
<span class="sd">        x_weight: User-provided `sample_weight` or `class_weight` argument.</span>
<span class="sd">        output_names: List of output names (strings) in the model.</span>
<span class="sd">        weight_type: A string used purely for exception printing.</span>

<span class="sd">    # Returns</span>
<span class="sd">        A list of `sample_weight` or `class_weight` where there are exactly</span>
<span class="sd">            one element per model output.</span>

<span class="sd">    # Raises</span>
<span class="sd">        ValueError: In case of invalid user-provided argument.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">x_weight</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="nb">len</span><span class="p">(</span><span class="n">x_weight</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="p">[</span><span class="kc">None</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="n">output_names</span><span class="p">]</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">output_names</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">x_weight</span><span class="p">,</span> <span class="nb">list</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">x_weight</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">x_weight</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">x_weight</span><span class="p">,</span> <span class="nb">dict</span><span class="p">)</span> <span class="ow">and</span> <span class="n">output_names</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">in</span> <span class="n">x_weight</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">[</span><span class="n">x_weight</span><span class="p">[</span><span class="n">output_names</span><span class="p">[</span><span class="mi">0</span><span class="p">]]]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">[</span><span class="n">x_weight</span><span class="p">]</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">x_weight</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">x_weight</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">output_names</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Provided `&#39;</span> <span class="o">+</span> <span class="n">weight_type</span> <span class="o">+</span> <span class="s1">&#39;` was a list of &#39;</span> <span class="o">+</span>
                             <span class="nb">str</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">x_weight</span><span class="p">))</span> <span class="o">+</span>
                             <span class="s1">&#39; elements, but the model has &#39;</span> <span class="o">+</span>
                             <span class="nb">str</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">output_names</span><span class="p">))</span> <span class="o">+</span> <span class="s1">&#39; outputs. &#39;</span>
                             <span class="s1">&#39;You should provide one `&#39;</span> <span class="o">+</span> <span class="n">weight_type</span> <span class="o">+</span> <span class="s1">&#39;`&#39;</span>
                             <span class="s1">&#39;array per model output.&#39;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">x_weight</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">x_weight</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
        <span class="n">x_weights</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">output_names</span><span class="p">:</span>
            <span class="n">x_weights</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">x_weight</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">name</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">x_weights</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;The model has multiple outputs, so `&#39;</span> <span class="o">+</span>
                        <span class="n">weight_type</span> <span class="o">+</span> <span class="s1">&#39;` &#39;</span>
                        <span class="s1">&#39;should be either a list of a dict. &#39;</span>
                        <span class="s1">&#39;Provided `&#39;</span> <span class="o">+</span> <span class="n">weight_type</span> <span class="o">+</span>
                        <span class="s1">&#39;` type not understood: &#39;</span> <span class="o">+</span>
                        <span class="nb">str</span><span class="p">(</span><span class="n">x_weight</span><span class="p">))</span>


<span class="k">def</span> <span class="nf">_standardize_class_weights</span><span class="p">(</span><span class="n">class_weight</span><span class="p">,</span> <span class="n">output_names</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">_standardize_sample_or_class_weights</span><span class="p">(</span><span class="n">class_weight</span><span class="p">,</span>
                                                <span class="n">output_names</span><span class="p">,</span>
                                                <span class="s1">&#39;class_weight&#39;</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">_standardize_sample_weights</span><span class="p">(</span><span class="n">sample_weight</span><span class="p">,</span> <span class="n">output_names</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">_standardize_sample_or_class_weights</span><span class="p">(</span><span class="n">sample_weight</span><span class="p">,</span>
                                                <span class="n">output_names</span><span class="p">,</span>
                                                <span class="s1">&#39;sample_weight&#39;</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">_check_array_lengths</span><span class="p">(</span><span class="n">inputs</span><span class="p">,</span> <span class="n">targets</span><span class="p">,</span> <span class="n">weights</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Does user input validation for numpy arrays.</span>

<span class="sd">    # Arguments</span>
<span class="sd">        inputs: list of Numpy arrays of inputs.</span>
<span class="sd">        targets: list of Numpy arrays of targets.</span>
<span class="sd">        weights: list of Numpy arrays of sample weights.</span>

<span class="sd">    # Raises</span>
<span class="sd">        ValueError: in case of incorrectly formatted data.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">set_of_lengths</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
        <span class="c1"># return a set with the variation between</span>
        <span class="c1"># different shapes, with None =&gt; 0</span>
        <span class="k">if</span> <span class="n">x</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">{</span><span class="mi">0</span><span class="p">}</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">set</span><span class="p">([</span><span class="mi">0</span> <span class="k">if</span> <span class="n">y</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">y</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">y</span> <span class="ow">in</span> <span class="n">x</span><span class="p">])</span>

    <span class="n">set_x</span> <span class="o">=</span> <span class="n">set_of_lengths</span><span class="p">(</span><span class="n">inputs</span><span class="p">)</span>
    <span class="n">set_y</span> <span class="o">=</span> <span class="n">set_of_lengths</span><span class="p">(</span><span class="n">targets</span><span class="p">)</span>
    <span class="n">set_w</span> <span class="o">=</span> <span class="n">set_of_lengths</span><span class="p">(</span><span class="n">weights</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">set_x</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;All input arrays (x) should have &#39;</span>
                         <span class="s1">&#39;the same number of samples. Got array shapes: &#39;</span> <span class="o">+</span>
                         <span class="nb">str</span><span class="p">([</span><span class="n">x</span><span class="o">.</span><span class="n">shape</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">inputs</span><span class="p">]))</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">set_y</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;All target arrays (y) should have &#39;</span>
                         <span class="s1">&#39;the same number of samples. Got array shapes: &#39;</span> <span class="o">+</span>
                         <span class="nb">str</span><span class="p">([</span><span class="n">y</span><span class="o">.</span><span class="n">shape</span> <span class="k">for</span> <span class="n">y</span> <span class="ow">in</span> <span class="n">targets</span><span class="p">]))</span>
    <span class="k">if</span> <span class="n">set_x</span> <span class="ow">and</span> <span class="n">set_y</span> <span class="ow">and</span> <span class="nb">list</span><span class="p">(</span><span class="n">set_x</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="nb">list</span><span class="p">(</span><span class="n">set_y</span><span class="p">)[</span><span class="mi">0</span><span class="p">]:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Input arrays should have &#39;</span>
                         <span class="s1">&#39;the same number of samples as target arrays. &#39;</span>
                         <span class="s1">&#39;Found &#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">set_x</span><span class="p">)[</span><span class="mi">0</span><span class="p">])</span> <span class="o">+</span> <span class="s1">&#39; input samples &#39;</span>
                         <span class="s1">&#39;and &#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">set_y</span><span class="p">)[</span><span class="mi">0</span><span class="p">])</span> <span class="o">+</span> <span class="s1">&#39; target samples.&#39;</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">set_w</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;All sample_weight arrays should have &#39;</span>
                         <span class="s1">&#39;the same number of samples. Got array shapes: &#39;</span> <span class="o">+</span>
                         <span class="nb">str</span><span class="p">([</span><span class="n">w</span><span class="o">.</span><span class="n">shape</span> <span class="k">for</span> <span class="n">w</span> <span class="ow">in</span> <span class="n">weights</span><span class="p">]))</span>
    <span class="k">if</span> <span class="n">set_y</span> <span class="ow">and</span> <span class="n">set_w</span> <span class="ow">and</span> <span class="nb">list</span><span class="p">(</span><span class="n">set_y</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="nb">list</span><span class="p">(</span><span class="n">set_w</span><span class="p">)[</span><span class="mi">0</span><span class="p">]:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Sample_weight arrays should have &#39;</span>
                         <span class="s1">&#39;the same number of samples as target arrays. Got &#39;</span> <span class="o">+</span>
                         <span class="nb">str</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">set_y</span><span class="p">)[</span><span class="mi">0</span><span class="p">])</span> <span class="o">+</span> <span class="s1">&#39; input samples and &#39;</span> <span class="o">+</span>
                         <span class="nb">str</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">set_w</span><span class="p">)[</span><span class="mi">0</span><span class="p">])</span> <span class="o">+</span> <span class="s1">&#39; target samples.&#39;</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">_check_loss_and_target_compatibility</span><span class="p">(</span><span class="n">targets</span><span class="p">,</span> <span class="n">loss_fns</span><span class="p">,</span> <span class="n">output_shapes</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Does validation on the compatibility of targets and loss functions.</span>

<span class="sd">    This helps prevent users from using loss functions incorrectly.</span>

<span class="sd">    # Arguments</span>
<span class="sd">        targets: list of Numpy arrays of targets.</span>
<span class="sd">        loss_fns: list of loss functions.</span>
<span class="sd">        output_shapes: list of shapes of model outputs.</span>

<span class="sd">    # Raises</span>
<span class="sd">        ValueError: if a loss function or target array</span>
<span class="sd">            is incompatible with an output.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">key_losses</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;mean_squared_error&#39;</span><span class="p">,</span>
                  <span class="s1">&#39;binary_crossentropy&#39;</span><span class="p">,</span>
                  <span class="s1">&#39;categorical_crossentropy&#39;</span><span class="p">}</span>
    <span class="k">for</span> <span class="n">y</span><span class="p">,</span> <span class="n">loss</span><span class="p">,</span> <span class="n">shape</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">targets</span><span class="p">,</span> <span class="n">loss_fns</span><span class="p">,</span> <span class="n">output_shapes</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">loss</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">continue</span>
        <span class="k">if</span> <span class="n">loss</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">==</span> <span class="s1">&#39;categorical_crossentropy&#39;</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">y</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="s1">&#39;You are passing a target array of shape &#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">y</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">+</span>
                    <span class="s1">&#39; while using as loss `categorical_crossentropy`. &#39;</span>
                    <span class="s1">&#39;`categorical_crossentropy` expects &#39;</span>
                    <span class="s1">&#39;targets to be binary matrices (1s and 0s) &#39;</span>
                    <span class="s1">&#39;of shape (samples, classes). &#39;</span>
                    <span class="s1">&#39;If your targets are integer classes, &#39;</span>
                    <span class="s1">&#39;you can convert them to the expected format via:</span><span class="se">\n</span><span class="s1">&#39;</span>
                    <span class="s1">&#39;```</span><span class="se">\n</span><span class="s1">&#39;</span>
                    <span class="s1">&#39;from keras.utils.np_utils import to_categorical</span><span class="se">\n</span><span class="s1">&#39;</span>
                    <span class="s1">&#39;y_binary = to_categorical(y_int)</span><span class="se">\n</span><span class="s1">&#39;</span>
                    <span class="s1">&#39;```</span><span class="se">\n</span><span class="s1">&#39;</span>
                    <span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span>
                    <span class="s1">&#39;Alternatively, you can use the loss function &#39;</span>
                    <span class="s1">&#39;`sparse_categorical_crossentropy` instead, &#39;</span>
                    <span class="s1">&#39;which does expect integer targets.&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">loss</span><span class="o">.</span><span class="vm">__name__</span> <span class="ow">in</span> <span class="n">key_losses</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">target_dim</span><span class="p">,</span> <span class="n">out_dim</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">y</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">:],</span> <span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">:]):</span>
                <span class="k">if</span> <span class="n">out_dim</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">target_dim</span> <span class="o">!=</span> <span class="n">out_dim</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                        <span class="s1">&#39;A target array with shape &#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">y</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">+</span>
                        <span class="s1">&#39; was passed for an output of shape &#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">shape</span><span class="p">)</span> <span class="o">+</span>
                        <span class="s1">&#39; while using as loss `&#39;</span> <span class="o">+</span> <span class="n">loss</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">+</span> <span class="s1">&#39;`. &#39;</span>
                        <span class="s1">&#39;This loss expects &#39;</span>
                        <span class="s1">&#39;targets to have the same shape &#39;</span>
                        <span class="s1">&#39;as the output.&#39;</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">_collect_metrics</span><span class="p">(</span><span class="n">metrics</span><span class="p">,</span> <span class="n">output_names</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Maps metric functions to model outputs.</span>

<span class="sd">    # Arguments</span>
<span class="sd">        metrics: a list or dict of metric functions.</span>
<span class="sd">        output_names: a list of the names (strings) of model outputs.</span>

<span class="sd">    # Returns</span>
<span class="sd">        A list (one entry per model output) of lists of metric functions.</span>
<span class="sd">        For instance, if the model has 2 outputs, and for the first output</span>
<span class="sd">        we want to compute &quot;binary_accuracy&quot; and &quot;binary_crossentropy&quot;,</span>
<span class="sd">        and just &quot;binary_accuracy&quot; for the second output,</span>
<span class="sd">        the list would look like:</span>
<span class="sd">            `[[binary_accuracy, binary_crossentropy], [binary_accuracy]]`</span>

<span class="sd">    # Raises</span>
<span class="sd">        TypeError: if an incorrect type is passed for the `metrics` argument.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">metrics</span><span class="p">:</span>
        <span class="k">return</span> <span class="p">[[]</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="n">output_names</span><span class="p">]</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">metrics</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
        <span class="c1"># we then apply all metrics to all outputs.</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">copy</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">metrics</span><span class="p">)</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="n">output_names</span><span class="p">]</span>
    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">metrics</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
        <span class="n">nested_metrics</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">output_names</span><span class="p">:</span>
            <span class="n">output_metrics</span> <span class="o">=</span> <span class="n">metrics</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="p">[])</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">output_metrics</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
                <span class="n">output_metrics</span> <span class="o">=</span> <span class="p">[</span><span class="n">output_metrics</span><span class="p">]</span>
            <span class="n">nested_metrics</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">output_metrics</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">nested_metrics</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;Type of `metrics` argument not understood. &#39;</span>
                        <span class="s1">&#39;Expected a list or dictionary, found: &#39;</span> <span class="o">+</span>
                        <span class="nb">str</span><span class="p">(</span><span class="n">metrics</span><span class="p">))</span>


<span class="k">def</span> <span class="nf">_batch_shuffle</span><span class="p">(</span><span class="n">index_array</span><span class="p">,</span> <span class="n">batch_size</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Shuffles an array in a batch-wise fashion.</span>

<span class="sd">    Useful for shuffling HDF5 arrays</span>
<span class="sd">    (where one cannot access arbitrary indices).</span>

<span class="sd">    # Arguments</span>
<span class="sd">        index_array: array of indices to be shuffled.</span>
<span class="sd">        batch_size: integer.</span>

<span class="sd">    # Returns</span>
<span class="sd">        The `index_array` array, shuffled in a batch-wise fashion.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">batch_count</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">index_array</span><span class="p">)</span> <span class="o">/</span> <span class="n">batch_size</span><span class="p">)</span>
    <span class="c1"># to reshape we need to be cleanly divisible by batch size</span>
    <span class="c1"># we stash extra items and reappend them after shuffling</span>
    <span class="n">last_batch</span> <span class="o">=</span> <span class="n">index_array</span><span class="p">[</span><span class="n">batch_count</span> <span class="o">*</span> <span class="n">batch_size</span><span class="p">:]</span>
    <span class="n">index_array</span> <span class="o">=</span> <span class="n">index_array</span><span class="p">[:</span><span class="n">batch_count</span> <span class="o">*</span> <span class="n">batch_size</span><span class="p">]</span>
    <span class="n">index_array</span> <span class="o">=</span> <span class="n">index_array</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="n">batch_count</span><span class="p">,</span> <span class="n">batch_size</span><span class="p">))</span>
    <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">shuffle</span><span class="p">(</span><span class="n">index_array</span><span class="p">)</span>
    <span class="n">index_array</span> <span class="o">=</span> <span class="n">index_array</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">index_array</span><span class="p">,</span> <span class="n">last_batch</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">_make_batches</span><span class="p">(</span><span class="n">size</span><span class="p">,</span> <span class="n">batch_size</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Returns a list of batch indices (tuples of indices).</span>

<span class="sd">    # Arguments</span>
<span class="sd">        size: Integer, total size of the data to slice into batches.</span>
<span class="sd">        batch_size: Integer, batch size.</span>

<span class="sd">    # Returns</span>
<span class="sd">        A list of tuples of array indices.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">num_batches</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="n">size</span> <span class="o">/</span> <span class="nb">float</span><span class="p">(</span><span class="n">batch_size</span><span class="p">)))</span>
    <span class="k">return</span> <span class="p">[(</span><span class="n">i</span> <span class="o">*</span> <span class="n">batch_size</span><span class="p">,</span> <span class="nb">min</span><span class="p">(</span><span class="n">size</span><span class="p">,</span> <span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">batch_size</span><span class="p">))</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">num_batches</span><span class="p">)]</span>


<span class="k">def</span> <span class="nf">_slice_arrays</span><span class="p">(</span><span class="n">arrays</span><span class="p">,</span> <span class="n">start</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">stop</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Slice an array or list of arrays.</span>

<span class="sd">    This takes an array-like, or a list of</span>
<span class="sd">    array-likes, and outputs:</span>
<span class="sd">        - arrays[start:stop] if `arrays` is an array-like</span>
<span class="sd">        - [x[start:stop] for x in arrays] if `arrays` is a list</span>

<span class="sd">    Can also work on list/array of indices: `_slice_arrays(x, indices)`</span>

<span class="sd">    # Arguments</span>
<span class="sd">        arrays: Single array or list of arrays.</span>
<span class="sd">        start: can be an integer index (start index)</span>
<span class="sd">            or a list/array of indices</span>
<span class="sd">        stop: integer (stop index); should be None if</span>
<span class="sd">            `start` was a list.</span>

<span class="sd">    # Returns</span>
<span class="sd">        A slice of the array(s).</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">arrays</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">return</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span>
    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">arrays</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="s1">&#39;__len__&#39;</span><span class="p">):</span>
            <span class="c1"># hdf5 datasets only support list objects as indices</span>
            <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="s1">&#39;shape&#39;</span><span class="p">):</span>
                <span class="n">start</span> <span class="o">=</span> <span class="n">start</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
            <span class="k">return</span> <span class="p">[</span><span class="kc">None</span> <span class="k">if</span> <span class="n">x</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">x</span><span class="p">[</span><span class="n">start</span><span class="p">]</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">arrays</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">[</span><span class="kc">None</span> <span class="k">if</span> <span class="n">x</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">x</span><span class="p">[</span><span class="n">start</span><span class="p">:</span><span class="n">stop</span><span class="p">]</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">arrays</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="s1">&#39;__len__&#39;</span><span class="p">):</span>
            <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="s1">&#39;shape&#39;</span><span class="p">):</span>
                <span class="n">start</span> <span class="o">=</span> <span class="n">start</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
            <span class="k">return</span> <span class="n">arrays</span><span class="p">[</span><span class="n">start</span><span class="p">]</span>
        <span class="k">elif</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="s1">&#39;__getitem__&#39;</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">arrays</span><span class="p">[</span><span class="n">start</span><span class="p">:</span><span class="n">stop</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span>


<span class="k">def</span> <span class="nf">_weighted_masked_objective</span><span class="p">(</span><span class="n">fn</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Adds support for masking and sample-weighting to an objective function.</span>

<span class="sd">    It transforms an objective function `fn(y_true, y_pred)`</span>
<span class="sd">    into a sample-weighted, cost-masked objective function</span>
<span class="sd">    `fn(y_true, y_pred, weights, mask)`.</span>

<span class="sd">    # Arguments</span>
<span class="sd">        fn: The objective function to wrap,</span>
<span class="sd">            with signature `fn(y_true, y_pred)`.</span>

<span class="sd">    # Returns</span>
<span class="sd">        A function with signature `fn(y_true, y_pred, weights, mask)`.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">fn</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">return</span> <span class="kc">None</span>

    <span class="k">def</span> <span class="nf">weighted</span><span class="p">(</span><span class="n">y_true</span><span class="p">,</span> <span class="n">y_pred</span><span class="p">,</span> <span class="n">weights</span><span class="p">,</span> <span class="n">mask</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Wrapper function.</span>

<span class="sd">        # Arguments</span>
<span class="sd">            y_true: `y_true` argument of `fn`.</span>
<span class="sd">            y_pred: `y_pred` argument of `fn`.</span>
<span class="sd">            weights: Weights tensor.</span>
<span class="sd">            mask: Mask tensor.</span>

<span class="sd">        # Returns</span>
<span class="sd">            Scalar tensor.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># score_array has ndim &gt;= 2</span>
        <span class="n">score_array</span> <span class="o">=</span> <span class="n">fn</span><span class="p">(</span><span class="n">y_true</span><span class="p">,</span> <span class="n">y_pred</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">mask</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># Cast the mask to floatX to avoid float64 upcasting in theano</span>
            <span class="n">mask</span> <span class="o">=</span> <span class="n">K</span><span class="o">.</span><span class="n">cast</span><span class="p">(</span><span class="n">mask</span><span class="p">,</span> <span class="n">K</span><span class="o">.</span><span class="n">floatx</span><span class="p">())</span>
            <span class="c1"># mask should have the same shape as score_array</span>
            <span class="n">score_array</span> <span class="o">*=</span> <span class="n">mask</span>
            <span class="c1">#  the loss per batch should be proportional</span>
            <span class="c1">#  to the number of unmasked samples.</span>
            <span class="n">score_array</span> <span class="o">/=</span> <span class="n">K</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">mask</span><span class="p">)</span>

        <span class="c1"># apply sample weighting</span>
        <span class="k">if</span> <span class="n">weights</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># reduce score_array to same ndim as weight array</span>
            <span class="n">ndim</span> <span class="o">=</span> <span class="n">K</span><span class="o">.</span><span class="n">ndim</span><span class="p">(</span><span class="n">score_array</span><span class="p">)</span>
            <span class="n">weight_ndim</span> <span class="o">=</span> <span class="n">K</span><span class="o">.</span><span class="n">ndim</span><span class="p">(</span><span class="n">weights</span><span class="p">)</span>
            <span class="n">score_array</span> <span class="o">=</span> <span class="n">K</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">score_array</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">weight_ndim</span><span class="p">,</span> <span class="n">ndim</span><span class="p">)))</span>
            <span class="n">score_array</span> <span class="o">*=</span> <span class="n">weights</span>
            <span class="n">score_array</span> <span class="o">/=</span> <span class="n">K</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">K</span><span class="o">.</span><span class="n">cast</span><span class="p">(</span><span class="n">K</span><span class="o">.</span><span class="n">not_equal</span><span class="p">(</span><span class="n">weights</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="n">K</span><span class="o">.</span><span class="n">floatx</span><span class="p">()))</span>
        <span class="k">return</span> <span class="n">K</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">score_array</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">weighted</span>


<span class="k">def</span> <span class="nf">_standardize_weights</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">sample_weight</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">class_weight</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                         <span class="n">sample_weight_mode</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Performs sample weight validation and standardization.</span>

<span class="sd">    Everything gets normalized to a single sample-wise (or timestep-wise)</span>
<span class="sd">    weight array.</span>

<span class="sd">    # Arguments</span>
<span class="sd">        y: Numpy array of model targets to be weighted.</span>
<span class="sd">        sample_weight: User-provided `sample_weight` argument.</span>
<span class="sd">        class_weight: User-provided `class_weight` argument.</span>
<span class="sd">        sample_weight_mode: One of `None` or `&quot;temporal&quot;`.</span>
<span class="sd">            `&quot;temporal&quot;` indicated that we expect 2D weight data</span>
<span class="sd">            that will be applied to the last 2 dimensions of</span>
<span class="sd">            the targets (i.e. we are weighting timesteps, not samples).</span>

<span class="sd">    # Returns</span>
<span class="sd">        A numpy array of target weights, one entry per sample to weight.</span>

<span class="sd">    # Raises</span>
<span class="sd">        ValueError: In case of invalid user-provided arguments.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">sample_weight_mode</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">sample_weight_mode</span> <span class="o">!=</span> <span class="s1">&#39;temporal&#39;</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;&quot;sample_weight_mode &#39;</span>
                             <span class="s1">&#39;should be None or &quot;temporal&quot;. &#39;</span>
                             <span class="s1">&#39;Found: &#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">sample_weight_mode</span><span class="p">))</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">y</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">3</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Found a sample_weight array for &#39;</span>
                             <span class="s1">&#39;an input with shape &#39;</span> <span class="o">+</span>
                             <span class="nb">str</span><span class="p">(</span><span class="n">y</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">+</span> <span class="s1">&#39;. &#39;</span>
                             <span class="s1">&#39;Timestep-wise sample weighting (use of &#39;</span>
                             <span class="s1">&#39;sample_weight_mode=&quot;temporal&quot;) is restricted to &#39;</span>
                             <span class="s1">&#39;outputs that are at least 3D, i.e. that have &#39;</span>
                             <span class="s1">&#39;a time dimension.&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">sample_weight</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">sample_weight</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">2</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Found a sample_weight array with shape &#39;</span> <span class="o">+</span>
                             <span class="nb">str</span><span class="p">(</span><span class="n">sample_weight</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">+</span> <span class="s1">&#39;. &#39;</span>
                             <span class="s1">&#39;In order to use timestep-wise sample weighting, &#39;</span>
                             <span class="s1">&#39;you should pass a 2D sample_weight array.&#39;</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">sample_weight</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">sample_weight</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Found a sample_weight array with shape &#39;</span> <span class="o">+</span>
                             <span class="nb">str</span><span class="p">(</span><span class="n">sample_weight</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">+</span> <span class="s1">&#39;. &#39;</span>
                             <span class="s1">&#39;In order to use timestep-wise sample weights, &#39;</span>
                             <span class="s1">&#39;you should specify &#39;</span>
                             <span class="s1">&#39;sample_weight_mode=&quot;temporal&quot; &#39;</span>
                             <span class="s1">&#39;in compile(). If you just mean to use &#39;</span>
                             <span class="s1">&#39;sample-wise weights, make sure your &#39;</span>
                             <span class="s1">&#39;sample_weight array is 1D.&#39;</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">sample_weight</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">sample_weight</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">&gt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">y</span><span class="o">.</span><span class="n">shape</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Found a sample_weight with shape&#39;</span> <span class="o">+</span>
                             <span class="nb">str</span><span class="p">(</span><span class="n">sample_weight</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">+</span> <span class="s1">&#39;.&#39;</span>
                             <span class="s1">&#39;Expected sample_weight with rank &#39;</span>
                             <span class="s1">&#39;less than or equal to &#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">y</span><span class="o">.</span><span class="n">shape</span><span class="p">)))</span>

        <span class="k">if</span> <span class="n">y</span><span class="o">.</span><span class="n">shape</span><span class="p">[:</span><span class="n">sample_weight</span><span class="o">.</span><span class="n">ndim</span><span class="p">]</span> <span class="o">!=</span> <span class="n">sample_weight</span><span class="o">.</span><span class="n">shape</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Found a sample_weight array with shape &#39;</span> <span class="o">+</span>
                             <span class="nb">str</span><span class="p">(</span><span class="n">sample_weight</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">+</span> <span class="s1">&#39; for an input with shape &#39;</span> <span class="o">+</span>
                             <span class="nb">str</span><span class="p">(</span><span class="n">y</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">+</span> <span class="s1">&#39;. &#39;</span>
                             <span class="s1">&#39;sample_weight cannot be broadcast.&#39;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">sample_weight</span>
    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">class_weight</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">y</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;`class_weight` not supported for &#39;</span>
                             <span class="s1">&#39;3+ dimensional targets.&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">y</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">y_classes</span> <span class="o">=</span> <span class="n">y</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">y</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">y_classes</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">y</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">y_classes</span> <span class="o">=</span> <span class="n">y</span>

        <span class="n">weights</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">([</span><span class="n">class_weight</span><span class="p">[</span><span class="bp">cls</span><span class="p">]</span> <span class="k">for</span> <span class="bp">cls</span> <span class="ow">in</span> <span class="n">y_classes</span>
                              <span class="k">if</span> <span class="bp">cls</span> <span class="ow">in</span> <span class="n">class_weight</span><span class="p">])</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">weights</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">y_classes</span><span class="p">):</span>
            <span class="c1"># subtract the sets to pick all missing classes</span>
            <span class="n">existing_classes</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">y_classes</span><span class="p">)</span>
            <span class="n">existing_class_weight</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">class_weight</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;`class_weight` must contain all classes in the data.&#39;</span>
                             <span class="s1">&#39; The classes </span><span class="si">%s</span><span class="s1"> exist in the data but not in &#39;</span>
                             <span class="s1">&#39;`class_weight`.&#39;</span>
                             <span class="o">%</span> <span class="p">(</span><span class="n">existing_classes</span> <span class="o">-</span> <span class="n">existing_class_weight</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">weights</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">sample_weight_mode</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="n">y</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">K</span><span class="o">.</span><span class="n">floatx</span><span class="p">())</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="n">y</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">y</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">K</span><span class="o">.</span><span class="n">floatx</span><span class="p">())</span>


<span class="k">class</span> <span class="nc">Model</span><span class="p">(</span><span class="n">Container</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;The `Model` class adds training &amp; evaluation routines to a `Container`.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">compile</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">optimizer</span><span class="p">,</span> <span class="n">loss</span><span class="p">,</span> <span class="n">metrics</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">loss_weights</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                <span class="n">sample_weight_mode</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">weighted_metrics</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                <span class="n">target_tensors</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Configures the model for training.</span>

<span class="sd">        # Arguments</span>
<span class="sd">            optimizer: String (name of optimizer) or optimizer object.</span>
<span class="sd">                See [optimizers](/optimizers).</span>
<span class="sd">            loss: String (name of objective function) or objective function.</span>
<span class="sd">                See [losses](/losses).</span>
<span class="sd">                If the model has multiple outputs, you can use a different loss</span>
<span class="sd">                on each output by passing a dictionary or a list of losses.</span>
<span class="sd">                The loss value that will be minimized by the model</span>
<span class="sd">                will then be the sum of all individual losses.</span>
<span class="sd">            metrics: List of metrics to be evaluated by the model</span>
<span class="sd">                during training and testing.</span>
<span class="sd">                Typically you will use `metrics=[&#39;accuracy&#39;]`.</span>
<span class="sd">                To specify different metrics for different outputs of a</span>
<span class="sd">                multi-output model, you could also pass a dictionary,</span>
<span class="sd">                such as `metrics={&#39;output_a&#39;: &#39;accuracy&#39;}`.</span>
<span class="sd">            loss_weights: Optional list or dictionary specifying scalar</span>
<span class="sd">                coefficients (Python floats) to weight the loss contributions</span>
<span class="sd">                of different model outputs.</span>
<span class="sd">                The loss value that will be minimized by the model</span>
<span class="sd">                will then be the *weighted sum* of all individual losses,</span>
<span class="sd">                weighted by the `loss_weights` coefficients.</span>
<span class="sd">                If a list, it is expected to have a 1:1 mapping</span>
<span class="sd">                to the model&#39;s outputs. If a tensor, it is expected to map</span>
<span class="sd">                output names (strings) to scalar coefficients.</span>
<span class="sd">            sample_weight_mode: If you need to do timestep-wise</span>
<span class="sd">                sample weighting (2D weights), set this to `&quot;temporal&quot;`.</span>
<span class="sd">                `None` defaults to sample-wise weights (1D).</span>
<span class="sd">                If the model has multiple outputs, you can use a different</span>
<span class="sd">                `sample_weight_mode` on each output by passing a</span>
<span class="sd">                dictionary or a list of modes.</span>
<span class="sd">            weighted_metrics: List of metrics to be evaluated and weighted</span>
<span class="sd">                by sample_weight or class_weight during training and testing.</span>
<span class="sd">            target_tensors: By default, Keras will create placeholders for the</span>
<span class="sd">                model&#39;s target, which will be fed with the target data during</span>
<span class="sd">                training. If instead you would like to use your own</span>
<span class="sd">                target tensors (in turn, Keras will not expect external</span>
<span class="sd">                Numpy data for these targets at training time), you</span>
<span class="sd">                can specify them via the `target_tensors` argument. It can be</span>
<span class="sd">                a single tensor (for a single-output model), a list of tensors,</span>
<span class="sd">                or a dict mapping output names to target tensors.</span>
<span class="sd">            **kwargs: When using the Theano/CNTK backends, these arguments</span>
<span class="sd">                are passed into K.function. When using the TensorFlow backend,</span>
<span class="sd">                these arguments are passed into `tf.Session.run`.</span>

<span class="sd">        # Raises</span>
<span class="sd">            ValueError: In case of invalid arguments for</span>
<span class="sd">                `optimizer`, `loss`, `metrics` or `sample_weight_mode`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">loss</span> <span class="o">=</span> <span class="n">loss</span> <span class="ow">or</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">optimizer</span> <span class="o">=</span> <span class="n">optimizers</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">optimizer</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sample_weight_mode</span> <span class="o">=</span> <span class="n">sample_weight_mode</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">loss</span> <span class="o">=</span> <span class="n">loss</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">loss_weights</span> <span class="o">=</span> <span class="n">loss_weights</span>

        <span class="c1"># Prepare loss functions.</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">loss</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">loss</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">name</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">output_names</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Unknown entry in loss &#39;</span>
                                     <span class="s1">&#39;dictionary: &quot;&#39;</span> <span class="o">+</span> <span class="n">name</span> <span class="o">+</span> <span class="s1">&#39;&quot;. &#39;</span>
                                     <span class="s1">&#39;Only expected the following keys: &#39;</span> <span class="o">+</span>
                                     <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">output_names</span><span class="p">))</span>
            <span class="n">loss_functions</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">output_names</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">name</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">loss</span><span class="p">:</span>
                    <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s1">&#39;Output &quot;&#39;</span> <span class="o">+</span> <span class="n">name</span> <span class="o">+</span>
                                  <span class="s1">&#39;&quot; missing from loss dictionary. &#39;</span>
                                  <span class="s1">&#39;We assume this was done on purpose, &#39;</span>
                                  <span class="s1">&#39;and we will not be expecting &#39;</span>
                                  <span class="s1">&#39;any data to be passed to &quot;&#39;</span> <span class="o">+</span> <span class="n">name</span> <span class="o">+</span>
                                  <span class="s1">&#39;&quot; during training.&#39;</span><span class="p">,</span> <span class="n">stacklevel</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
                <span class="n">loss_functions</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">losses</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">loss</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">name</span><span class="p">)))</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">loss</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">loss</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">outputs</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;When passing a list as loss, &#39;</span>
                                 <span class="s1">&#39;it should have one entry per model outputs. &#39;</span>
                                 <span class="s1">&#39;The model has &#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">outputs</span><span class="p">))</span> <span class="o">+</span>
                                 <span class="s1">&#39; outputs, but you passed loss=&#39;</span> <span class="o">+</span>
                                 <span class="nb">str</span><span class="p">(</span><span class="n">loss</span><span class="p">))</span>
            <span class="n">loss_functions</span> <span class="o">=</span> <span class="p">[</span><span class="n">losses</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">l</span><span class="p">)</span> <span class="k">for</span> <span class="n">l</span> <span class="ow">in</span> <span class="n">loss</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">loss_function</span> <span class="o">=</span> <span class="n">losses</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">loss</span><span class="p">)</span>
            <span class="n">loss_functions</span> <span class="o">=</span> <span class="p">[</span><span class="n">loss_function</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">outputs</span><span class="p">))]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">loss_functions</span> <span class="o">=</span> <span class="n">loss_functions</span>
        <span class="n">weighted_losses</span> <span class="o">=</span> <span class="p">[</span><span class="n">_weighted_masked_objective</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span> <span class="k">for</span> <span class="n">fn</span> <span class="ow">in</span> <span class="n">loss_functions</span><span class="p">]</span>
        <span class="n">skip_target_indices</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">skip_target_weighing_indices</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_feed_outputs</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_feed_output_names</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_feed_output_shapes</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_feed_loss_fns</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">weighted_losses</span><span class="p">)):</span>
            <span class="k">if</span> <span class="n">weighted_losses</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">skip_target_indices</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
                <span class="n">skip_target_weighing_indices</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>

        <span class="c1"># Prepare output masks.</span>
        <span class="n">masks</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">compute_mask</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">inputs</span><span class="p">,</span> <span class="n">mask</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">masks</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">masks</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">outputs</span><span class="p">]</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">masks</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
            <span class="n">masks</span> <span class="o">=</span> <span class="p">[</span><span class="n">masks</span><span class="p">]</span>

        <span class="c1"># Prepare loss weights.</span>
        <span class="k">if</span> <span class="n">loss_weights</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">loss_weights_list</span> <span class="o">=</span> <span class="p">[</span><span class="mf">1.</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">outputs</span><span class="p">))]</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">loss_weights</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">loss_weights</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">name</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">output_names</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Unknown entry in loss_weights &#39;</span>
                                     <span class="s1">&#39;dictionary: &quot;&#39;</span> <span class="o">+</span> <span class="n">name</span> <span class="o">+</span> <span class="s1">&#39;&quot;. &#39;</span>
                                     <span class="s1">&#39;Only expected the following keys: &#39;</span> <span class="o">+</span>
                                     <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">output_names</span><span class="p">))</span>
            <span class="n">loss_weights_list</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">output_names</span><span class="p">:</span>
                <span class="n">loss_weights_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">loss_weights</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="mf">1.</span><span class="p">))</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">loss_weights</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">loss_weights</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">outputs</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;When passing a list as loss_weights, &#39;</span>
                                 <span class="s1">&#39;it should have one entry per model outputs. &#39;</span>
                                 <span class="s1">&#39;The model has &#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">outputs</span><span class="p">))</span> <span class="o">+</span>
                                 <span class="s1">&#39; outputs, but you passed loss_weights=&#39;</span> <span class="o">+</span>
                                 <span class="nb">str</span><span class="p">(</span><span class="n">loss_weights</span><span class="p">))</span>
            <span class="n">loss_weights_list</span> <span class="o">=</span> <span class="n">loss_weights</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;Could not interpret loss_weights argument: &#39;</span> <span class="o">+</span>
                            <span class="nb">str</span><span class="p">(</span><span class="n">loss_weights</span><span class="p">)</span> <span class="o">+</span>
                            <span class="s1">&#39; - expected a list of dicts.&#39;</span><span class="p">)</span>

        <span class="c1"># Prepare targets of model.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">targets</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_feed_targets</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">if</span> <span class="n">target_tensors</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">target_tensors</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">target_tensors</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">outputs</span><span class="p">):</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                        <span class="s1">&#39;When passing a list as `target_tensors`, &#39;</span>
                        <span class="s1">&#39;it should have one entry per model outputs. &#39;</span>
                        <span class="s1">&#39;The model has &#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">outputs</span><span class="p">))</span> <span class="o">+</span>
                        <span class="s1">&#39; outputs, but you passed target_tensors=&#39;</span> <span class="o">+</span>
                        <span class="nb">str</span><span class="p">(</span><span class="n">target_tensors</span><span class="p">))</span>
            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">target_tensors</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
                <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">target_tensors</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">name</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">output_names</span><span class="p">:</span>
                        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Unknown entry in `target_tensors` &#39;</span>
                                         <span class="s1">&#39;dictionary: &quot;&#39;</span> <span class="o">+</span> <span class="n">name</span> <span class="o">+</span> <span class="s1">&#39;&quot;. &#39;</span>
                                         <span class="s1">&#39;Only expected the following keys: &#39;</span> <span class="o">+</span>
                                         <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">output_names</span><span class="p">))</span>
                <span class="n">_target_tensors</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">output_names</span><span class="p">:</span>
                    <span class="n">_target_tensors</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">target_tensors</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="kc">None</span><span class="p">))</span>
                <span class="n">target_tensors</span> <span class="o">=</span> <span class="n">_target_tensors</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;Expected `target_tensors` to be &#39;</span>
                                <span class="s1">&#39;a list or dict, but got:&#39;</span><span class="p">,</span> <span class="n">target_tensors</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">outputs</span><span class="p">)):</span>
            <span class="k">if</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">skip_target_indices</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">targets</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">shape</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">internal_output_shapes</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                <span class="n">name</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">output_names</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                <span class="k">if</span> <span class="n">target_tensors</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">target</span> <span class="o">=</span> <span class="n">target_tensors</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">target</span> <span class="o">=</span> <span class="kc">None</span>
                <span class="k">if</span> <span class="n">target</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">K</span><span class="o">.</span><span class="n">is_placeholder</span><span class="p">(</span><span class="n">target</span><span class="p">):</span>
                    <span class="k">if</span> <span class="n">target</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                        <span class="n">target</span> <span class="o">=</span> <span class="n">K</span><span class="o">.</span><span class="n">placeholder</span><span class="p">(</span><span class="n">ndim</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">shape</span><span class="p">),</span>
                                               <span class="n">name</span><span class="o">=</span><span class="n">name</span> <span class="o">+</span> <span class="s1">&#39;_target&#39;</span><span class="p">,</span>
                                               <span class="n">sparse</span><span class="o">=</span><span class="n">K</span><span class="o">.</span><span class="n">is_sparse</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">outputs</span><span class="p">[</span><span class="n">i</span><span class="p">]),</span>
                                               <span class="n">dtype</span><span class="o">=</span><span class="n">K</span><span class="o">.</span><span class="n">dtype</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">outputs</span><span class="p">[</span><span class="n">i</span><span class="p">]))</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_feed_targets</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">target</span><span class="p">)</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_feed_outputs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">outputs</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_feed_output_names</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_feed_output_shapes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">shape</span><span class="p">)</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_feed_loss_fns</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">loss_functions</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">skip_target_weighing_indices</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">targets</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">target</span><span class="p">)</span>

        <span class="c1"># Prepare sample weights.</span>
        <span class="n">sample_weights</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">sample_weight_modes</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">sample_weight_mode</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">sample_weight_mode</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">name</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">output_names</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Unknown entry in &#39;</span>
                                     <span class="s1">&#39;sample_weight_mode dictionary: &quot;&#39;</span> <span class="o">+</span>
                                     <span class="n">name</span> <span class="o">+</span> <span class="s1">&#39;&quot;. &#39;</span>
                                     <span class="s1">&#39;Only expected the following keys: &#39;</span> <span class="o">+</span>
                                     <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">output_names</span><span class="p">))</span>
            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">name</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">output_names</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">skip_target_weighing_indices</span><span class="p">:</span>
                    <span class="n">weight</span> <span class="o">=</span> <span class="kc">None</span>
                    <span class="n">sample_weight_modes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">name</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">sample_weight_mode</span><span class="p">:</span>
                        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Output &quot;&#39;</span> <span class="o">+</span> <span class="n">name</span> <span class="o">+</span>
                                         <span class="s1">&#39;&quot; missing from sample_weight_modes &#39;</span>
                                         <span class="s1">&#39;dictionary&#39;</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">sample_weight_mode</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">name</span><span class="p">)</span> <span class="o">==</span> <span class="s1">&#39;temporal&#39;</span><span class="p">:</span>
                        <span class="n">weight</span> <span class="o">=</span> <span class="n">K</span><span class="o">.</span><span class="n">placeholder</span><span class="p">(</span><span class="n">ndim</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span>
                                               <span class="n">name</span><span class="o">=</span><span class="n">name</span> <span class="o">+</span> <span class="s1">&#39;_sample_weights&#39;</span><span class="p">)</span>
                        <span class="n">sample_weight_modes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s1">&#39;temporal&#39;</span><span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">weight</span> <span class="o">=</span> <span class="n">K</span><span class="o">.</span><span class="n">placeholder</span><span class="p">(</span><span class="n">ndim</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
                                               <span class="n">name</span><span class="o">=</span><span class="n">name</span> <span class="o">+</span> <span class="s1">&#39;_sample_weights&#39;</span><span class="p">)</span>
                        <span class="n">sample_weight_modes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span>
                <span class="n">sample_weights</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">weight</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">sample_weight_mode</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">sample_weight_mode</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">outputs</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;When passing a list as sample_weight_mode, &#39;</span>
                                 <span class="s1">&#39;it should have one entry per model outputs. &#39;</span>
                                 <span class="s1">&#39;The model has &#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">outputs</span><span class="p">))</span> <span class="o">+</span>
                                 <span class="s1">&#39; outputs, but you passed &#39;</span>
                                 <span class="s1">&#39;sample_weight_mode=&#39;</span> <span class="o">+</span>
                                 <span class="nb">str</span><span class="p">(</span><span class="n">sample_weight_mode</span><span class="p">))</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">output_names</span><span class="p">)):</span>
                <span class="k">if</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">skip_target_weighing_indices</span><span class="p">:</span>
                    <span class="n">weight</span> <span class="o">=</span> <span class="kc">None</span>
                    <span class="n">sample_weight_modes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">mode</span> <span class="o">=</span> <span class="n">sample_weight_mode</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                    <span class="n">name</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">output_names</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                    <span class="k">if</span> <span class="n">mode</span> <span class="o">==</span> <span class="s1">&#39;temporal&#39;</span><span class="p">:</span>
                        <span class="n">weight</span> <span class="o">=</span> <span class="n">K</span><span class="o">.</span><span class="n">placeholder</span><span class="p">(</span><span class="n">ndim</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span>
                                               <span class="n">name</span><span class="o">=</span><span class="n">name</span> <span class="o">+</span> <span class="s1">&#39;_sample_weights&#39;</span><span class="p">)</span>
                        <span class="n">sample_weight_modes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s1">&#39;temporal&#39;</span><span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">weight</span> <span class="o">=</span> <span class="n">K</span><span class="o">.</span><span class="n">placeholder</span><span class="p">(</span><span class="n">ndim</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
                                               <span class="n">name</span><span class="o">=</span><span class="n">name</span> <span class="o">+</span> <span class="s1">&#39;_sample_weights&#39;</span><span class="p">)</span>
                        <span class="n">sample_weight_modes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span>
                <span class="n">sample_weights</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">weight</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">name</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">output_names</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">skip_target_weighing_indices</span><span class="p">:</span>
                    <span class="n">sample_weight_modes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span>
                    <span class="n">sample_weights</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">sample_weight_mode</span> <span class="o">==</span> <span class="s1">&#39;temporal&#39;</span><span class="p">:</span>
                        <span class="n">sample_weights</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                            <span class="n">K</span><span class="o">.</span><span class="n">placeholder</span><span class="p">(</span><span class="n">ndim</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span>
                                          <span class="n">name</span><span class="o">=</span><span class="n">name</span> <span class="o">+</span> <span class="s1">&#39;_sample_weights&#39;</span><span class="p">))</span>
                        <span class="n">sample_weight_modes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s1">&#39;temporal&#39;</span><span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">sample_weights</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                            <span class="n">K</span><span class="o">.</span><span class="n">placeholder</span><span class="p">(</span><span class="n">ndim</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
                                          <span class="n">name</span><span class="o">=</span><span class="n">name</span> <span class="o">+</span> <span class="s1">&#39;_sample_weights&#39;</span><span class="p">))</span>
                        <span class="n">sample_weight_modes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sample_weight_modes</span> <span class="o">=</span> <span class="n">sample_weight_modes</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_feed_sample_weight_modes</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">outputs</span><span class="p">)):</span>
            <span class="k">if</span> <span class="n">i</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">skip_target_weighing_indices</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_feed_sample_weight_modes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sample_weight_modes</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>

        <span class="c1"># Prepare metrics.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">metrics</span> <span class="o">=</span> <span class="n">metrics</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">weighted_metrics</span> <span class="o">=</span> <span class="n">weighted_metrics</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">metrics_names</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;loss&#39;</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">metrics_tensors</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="c1"># Compute total loss.</span>
        <span class="n">total_loss</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">with</span> <span class="n">K</span><span class="o">.</span><span class="n">name_scope</span><span class="p">(</span><span class="s1">&#39;loss&#39;</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">outputs</span><span class="p">)):</span>
                <span class="k">if</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">skip_target_indices</span><span class="p">:</span>
                    <span class="k">continue</span>
                <span class="n">y_true</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">targets</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                <span class="n">y_pred</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">outputs</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                <span class="n">weighted_loss</span> <span class="o">=</span> <span class="n">weighted_losses</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                <span class="n">sample_weight</span> <span class="o">=</span> <span class="n">sample_weights</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                <span class="n">mask</span> <span class="o">=</span> <span class="n">masks</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                <span class="n">loss_weight</span> <span class="o">=</span> <span class="n">loss_weights_list</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                <span class="k">with</span> <span class="n">K</span><span class="o">.</span><span class="n">name_scope</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">output_names</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="s1">&#39;_loss&#39;</span><span class="p">):</span>
                    <span class="n">output_loss</span> <span class="o">=</span> <span class="n">weighted_loss</span><span class="p">(</span><span class="n">y_true</span><span class="p">,</span> <span class="n">y_pred</span><span class="p">,</span>
                                                <span class="n">sample_weight</span><span class="p">,</span> <span class="n">mask</span><span class="p">)</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">outputs</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">metrics_tensors</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">output_loss</span><span class="p">)</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">metrics_names</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">output_names</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="s1">&#39;_loss&#39;</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">total_loss</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">total_loss</span> <span class="o">=</span> <span class="n">loss_weight</span> <span class="o">*</span> <span class="n">output_loss</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">total_loss</span> <span class="o">+=</span> <span class="n">loss_weight</span> <span class="o">*</span> <span class="n">output_loss</span>
            <span class="k">if</span> <span class="n">total_loss</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">losses</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;The model cannot be compiled &#39;</span>
                                     <span class="s1">&#39;because it has no loss to optimize.&#39;</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">total_loss</span> <span class="o">=</span> <span class="mf">0.</span>

            <span class="c1"># Add regularization penalties</span>
            <span class="c1"># and other layer-specific losses.</span>
            <span class="k">for</span> <span class="n">loss_tensor</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">losses</span><span class="p">:</span>
                <span class="n">total_loss</span> <span class="o">+=</span> <span class="n">loss_tensor</span>

        <span class="c1"># List of same size as output_names.</span>
        <span class="c1"># contains tuples (metrics for output, names of metrics).</span>
        <span class="n">nested_metrics</span> <span class="o">=</span> <span class="n">_collect_metrics</span><span class="p">(</span><span class="n">metrics</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">output_names</span><span class="p">)</span>
        <span class="n">nested_weighted_metrics</span> <span class="o">=</span> <span class="n">_collect_metrics</span><span class="p">(</span><span class="n">weighted_metrics</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">output_names</span><span class="p">)</span>

        <span class="k">def</span> <span class="nf">append_metric</span><span class="p">(</span><span class="n">layer_index</span><span class="p">,</span> <span class="n">metric_name</span><span class="p">,</span> <span class="n">metric_tensor</span><span class="p">):</span>
            <span class="sd">&quot;&quot;&quot;Helper function used in loop below.&quot;&quot;&quot;</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">output_names</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">metric_name</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">output_names</span><span class="p">[</span><span class="n">layer_index</span><span class="p">]</span> <span class="o">+</span> <span class="s1">&#39;_&#39;</span> <span class="o">+</span> <span class="n">metric_name</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">metrics_names</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">metric_name</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">metrics_tensors</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">metric_tensor</span><span class="p">)</span>

        <span class="k">with</span> <span class="n">K</span><span class="o">.</span><span class="n">name_scope</span><span class="p">(</span><span class="s1">&#39;metrics&#39;</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">outputs</span><span class="p">)):</span>
                <span class="k">if</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">skip_target_indices</span><span class="p">:</span>
                    <span class="k">continue</span>

                <span class="n">y_true</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">targets</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                <span class="n">y_pred</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">outputs</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                <span class="n">weights</span> <span class="o">=</span> <span class="n">sample_weights</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                <span class="n">output_metrics</span> <span class="o">=</span> <span class="n">nested_metrics</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                <span class="n">output_weighted_metrics</span> <span class="o">=</span> <span class="n">nested_weighted_metrics</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>

                <span class="k">def</span> <span class="nf">handle_metrics</span><span class="p">(</span><span class="n">metrics</span><span class="p">,</span> <span class="n">weights</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
                    <span class="n">metric_name_prefix</span> <span class="o">=</span> <span class="s1">&#39;weighted_&#39;</span> <span class="k">if</span> <span class="n">weights</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="s1">&#39;&#39;</span>

                    <span class="k">for</span> <span class="n">metric</span> <span class="ow">in</span> <span class="n">metrics</span><span class="p">:</span>
                        <span class="k">if</span> <span class="n">metric</span> <span class="o">==</span> <span class="s1">&#39;accuracy&#39;</span> <span class="ow">or</span> <span class="n">metric</span> <span class="o">==</span> <span class="s1">&#39;acc&#39;</span><span class="p">:</span>
                            <span class="c1"># custom handling of accuracy</span>
                            <span class="c1"># (because of class mode duality)</span>
                            <span class="n">output_shape</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">internal_output_shapes</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                            <span class="k">if</span> <span class="p">(</span><span class="n">output_shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">or</span>
                               <span class="bp">self</span><span class="o">.</span><span class="n">loss_functions</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="n">losses</span><span class="o">.</span><span class="n">binary_crossentropy</span><span class="p">):</span>
                                <span class="c1"># case: binary accuracy</span>
                                <span class="n">acc_fn</span> <span class="o">=</span> <span class="n">metrics_module</span><span class="o">.</span><span class="n">binary_accuracy</span>
                            <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">loss_functions</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="n">losses</span><span class="o">.</span><span class="n">sparse_categorical_crossentropy</span><span class="p">:</span>
                                <span class="c1"># case: categorical accuracy with sparse targets</span>
                                <span class="n">acc_fn</span> <span class="o">=</span> <span class="n">metrics_module</span><span class="o">.</span><span class="n">sparse_categorical_accuracy</span>
                            <span class="k">else</span><span class="p">:</span>
                                <span class="n">acc_fn</span> <span class="o">=</span> <span class="n">metrics_module</span><span class="o">.</span><span class="n">categorical_accuracy</span>

                            <span class="n">weighted_metric_fn</span> <span class="o">=</span> <span class="n">_weighted_masked_objective</span><span class="p">(</span><span class="n">acc_fn</span><span class="p">)</span>
                            <span class="n">metric_name</span> <span class="o">=</span> <span class="n">metric_name_prefix</span> <span class="o">+</span> <span class="s1">&#39;acc&#39;</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="n">metric_fn</span> <span class="o">=</span> <span class="n">metrics_module</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">metric</span><span class="p">)</span>
                            <span class="n">weighted_metric_fn</span> <span class="o">=</span> <span class="n">_weighted_masked_objective</span><span class="p">(</span><span class="n">metric_fn</span><span class="p">)</span>
                            <span class="n">metric_name</span> <span class="o">=</span> <span class="n">metric_name_prefix</span> <span class="o">+</span> <span class="n">metric_fn</span><span class="o">.</span><span class="vm">__name__</span>

                        <span class="k">with</span> <span class="n">K</span><span class="o">.</span><span class="n">name_scope</span><span class="p">(</span><span class="n">metric_name</span><span class="p">):</span>
                            <span class="n">metric_result</span> <span class="o">=</span> <span class="n">weighted_metric_fn</span><span class="p">(</span><span class="n">y_true</span><span class="p">,</span> <span class="n">y_pred</span><span class="p">,</span>
                                                               <span class="n">weights</span><span class="o">=</span><span class="n">weights</span><span class="p">,</span>
                                                               <span class="n">mask</span><span class="o">=</span><span class="n">masks</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
                        <span class="n">append_metric</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">metric_name</span><span class="p">,</span> <span class="n">metric_result</span><span class="p">)</span>

                <span class="n">handle_metrics</span><span class="p">(</span><span class="n">output_metrics</span><span class="p">)</span>
                <span class="n">handle_metrics</span><span class="p">(</span><span class="n">output_weighted_metrics</span><span class="p">,</span> <span class="n">weights</span><span class="o">=</span><span class="n">weights</span><span class="p">)</span>

        <span class="c1"># Prepare gradient updates and state updates.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">total_loss</span> <span class="o">=</span> <span class="n">total_loss</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sample_weights</span> <span class="o">=</span> <span class="n">sample_weights</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_feed_sample_weights</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sample_weights</span><span class="p">)):</span>
            <span class="k">if</span> <span class="n">i</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">skip_target_weighing_indices</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_feed_sample_weights</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">sample_weights</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>

        <span class="c1"># Functions for train, test and predict will</span>
        <span class="c1"># be compiled lazily when required.</span>
        <span class="c1"># This saves time when the user is not using all functions.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_function_kwargs</span> <span class="o">=</span> <span class="n">kwargs</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">train_function</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">test_function</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">predict_function</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="c1"># Collected trainable weights, sorted in topological order.</span>
        <span class="n">trainable_weights</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">trainable_weights</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_collected_trainable_weights</span> <span class="o">=</span> <span class="n">trainable_weights</span>

    <span class="k">def</span> <span class="nf">_make_train_function</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;train_function&#39;</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s1">&#39;You must compile your model before using it.&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">train_function</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">inputs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_feed_inputs</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">_feed_targets</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">_feed_sample_weights</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">uses_learning_phase</span> <span class="ow">and</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">K</span><span class="o">.</span><span class="n">learning_phase</span><span class="p">(),</span> <span class="nb">int</span><span class="p">):</span>
                <span class="n">inputs</span> <span class="o">+=</span> <span class="p">[</span><span class="n">K</span><span class="o">.</span><span class="n">learning_phase</span><span class="p">()]</span>

            <span class="k">with</span> <span class="n">K</span><span class="o">.</span><span class="n">name_scope</span><span class="p">(</span><span class="s1">&#39;training&#39;</span><span class="p">):</span>
                <span class="k">with</span> <span class="n">K</span><span class="o">.</span><span class="n">name_scope</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">optimizer</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="p">):</span>
                    <span class="n">training_updates</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">optimizer</span><span class="o">.</span><span class="n">get_updates</span><span class="p">(</span>
                        <span class="n">params</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_collected_trainable_weights</span><span class="p">,</span>
                        <span class="n">loss</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">total_loss</span><span class="p">)</span>
                <span class="n">updates</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">updates</span> <span class="o">+</span> <span class="n">training_updates</span>
                <span class="c1"># Gets loss and metrics. Updates weights at each call.</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">train_function</span> <span class="o">=</span> <span class="n">K</span><span class="o">.</span><span class="n">function</span><span class="p">(</span><span class="n">inputs</span><span class="p">,</span>
                                                 <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">total_loss</span><span class="p">]</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">metrics_tensors</span><span class="p">,</span>
                                                 <span class="n">updates</span><span class="o">=</span><span class="n">updates</span><span class="p">,</span>
                                                 <span class="n">name</span><span class="o">=</span><span class="s1">&#39;train_function&#39;</span><span class="p">,</span>
                                                 <span class="o">**</span><span class="bp">self</span><span class="o">.</span><span class="n">_function_kwargs</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_make_test_function</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;test_function&#39;</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s1">&#39;You must compile your model before using it.&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">test_function</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">inputs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_feed_inputs</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">_feed_targets</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">_feed_sample_weights</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">uses_learning_phase</span> <span class="ow">and</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">K</span><span class="o">.</span><span class="n">learning_phase</span><span class="p">(),</span> <span class="nb">int</span><span class="p">):</span>
                <span class="n">inputs</span> <span class="o">+=</span> <span class="p">[</span><span class="n">K</span><span class="o">.</span><span class="n">learning_phase</span><span class="p">()]</span>
            <span class="c1"># Return loss and metrics, no gradient updates.</span>
            <span class="c1"># Does update the network states.</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">test_function</span> <span class="o">=</span> <span class="n">K</span><span class="o">.</span><span class="n">function</span><span class="p">(</span><span class="n">inputs</span><span class="p">,</span>
                                            <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">total_loss</span><span class="p">]</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">metrics_tensors</span><span class="p">,</span>
                                            <span class="n">updates</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">state_updates</span><span class="p">,</span>
                                            <span class="n">name</span><span class="o">=</span><span class="s1">&#39;test_function&#39;</span><span class="p">,</span>
                                            <span class="o">**</span><span class="bp">self</span><span class="o">.</span><span class="n">_function_kwargs</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_make_predict_function</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;predict_function&#39;</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">predict_function</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">predict_function</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">uses_learning_phase</span> <span class="ow">and</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">K</span><span class="o">.</span><span class="n">learning_phase</span><span class="p">(),</span> <span class="nb">int</span><span class="p">):</span>
                <span class="n">inputs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_feed_inputs</span> <span class="o">+</span> <span class="p">[</span><span class="n">K</span><span class="o">.</span><span class="n">learning_phase</span><span class="p">()]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">inputs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_feed_inputs</span>
            <span class="c1"># Gets network outputs. Does not update weights.</span>
            <span class="c1"># Does update the network states.</span>
            <span class="n">kwargs</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;_function_kwargs&#39;</span><span class="p">,</span> <span class="p">{})</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">predict_function</span> <span class="o">=</span> <span class="n">K</span><span class="o">.</span><span class="n">function</span><span class="p">(</span><span class="n">inputs</span><span class="p">,</span>
                                               <span class="bp">self</span><span class="o">.</span><span class="n">outputs</span><span class="p">,</span>
                                               <span class="n">updates</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">state_updates</span><span class="p">,</span>
                                               <span class="n">name</span><span class="o">=</span><span class="s1">&#39;predict_function&#39;</span><span class="p">,</span>
                                               <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_check_num_samples</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ins</span><span class="p">,</span> <span class="n">batch_size</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">steps</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">steps_name</span><span class="o">=</span><span class="s1">&#39;steps&#39;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Determine the number of samples provided for training and evaluation.</span>

<span class="sd">        The number of samples is not defined when running with `steps`,</span>
<span class="sd">        in which case the number of samples is set to `None`.</span>

<span class="sd">        # Arguments</span>
<span class="sd">            ins: List of tensors to be fed to the Keras function.</span>
<span class="sd">            batch_size: Integer batch size or `None` if not defined.</span>
<span class="sd">            steps: Total number of steps (batches of samples)</span>
<span class="sd">                before declaring `_predict_loop` finished.</span>
<span class="sd">                Ignored with the default value of `None`.</span>
<span class="sd">            steps_name: The public API&#39;s parameter name for `steps`.</span>

<span class="sd">        # Raises</span>
<span class="sd">            ValueError: when `steps` is `None` and the attribute `ins.shape`</span>
<span class="sd">            does not exist. Also raises ValueError when `steps` is not `None`</span>
<span class="sd">            and `batch_size` is not `None` because they are mutually</span>
<span class="sd">            exclusive.</span>

<span class="sd">        # Returns</span>
<span class="sd">            When steps is `None`, returns the number of samples to be</span>
<span class="sd">            processed based on the size of the first dimension of the</span>
<span class="sd">            first input numpy array. When steps is not `None` and</span>
<span class="sd">            `batch_size` is `None`, returns `None`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">steps</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">num_samples</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="k">if</span> <span class="n">batch_size</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;If &#39;</span> <span class="o">+</span> <span class="n">steps_name</span> <span class="o">+</span>
                                 <span class="s1">&#39; is set, the `batch_size` must be None.&#39;</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">ins</span> <span class="ow">and</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">ins</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="s1">&#39;shape&#39;</span><span class="p">):</span>
            <span class="n">num_samples</span> <span class="o">=</span> <span class="n">ins</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Either the input data should have &#39;</span>
                             <span class="s1">&#39;a defined shape, or &#39;</span> <span class="o">+</span> <span class="n">steps_name</span> <span class="o">+</span>
                             <span class="s1">&#39; should be specified.&#39;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">num_samples</span>

    <span class="k">def</span> <span class="nf">_fit_loop</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="n">ins</span><span class="p">,</span> <span class="n">out_labels</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">batch_size</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                  <span class="n">epochs</span><span class="o">=</span><span class="mi">100</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">callbacks</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                  <span class="n">val_f</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">val_ins</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">shuffle</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                  <span class="n">callback_metrics</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">initial_epoch</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
                  <span class="n">steps_per_epoch</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">validation_steps</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Abstract fit function for `f(ins)`.</span>

<span class="sd">        Assume that f returns a list, labeled by out_labels.</span>

<span class="sd">        # Arguments</span>
<span class="sd">            f: Keras function returning a list of tensors</span>
<span class="sd">            ins: List of tensors to be fed to `f`</span>
<span class="sd">            out_labels: List of strings, display names of</span>
<span class="sd">                the outputs of `f`</span>
<span class="sd">            batch_size: Integer batch size or None if unknown.</span>
<span class="sd">            epochs: Number of times to iterate over the data</span>
<span class="sd">            verbose: Verbosity mode, 0, 1 or 2</span>
<span class="sd">            callbacks: List of callbacks to be called during training</span>
<span class="sd">            val_f: Keras function to call for validation</span>
<span class="sd">            val_ins: List of tensors to be fed to `val_f`</span>
<span class="sd">            shuffle: Whether to shuffle the data at the beginning of each epoch</span>
<span class="sd">            callback_metrics: List of strings, the display names of the metrics</span>
<span class="sd">                passed to the callbacks. They should be the</span>
<span class="sd">                concatenation of list the display names of the outputs of</span>
<span class="sd">                 `f` and the list of display names of the outputs of `f_val`.</span>
<span class="sd">            initial_epoch: Epoch at which to start training</span>
<span class="sd">                (useful for resuming a previous training run)</span>
<span class="sd">            steps_per_epoch: Total number of steps (batches of samples)</span>
<span class="sd">                before declaring one epoch finished and starting the</span>
<span class="sd">                next epoch. Ignored with the default value of `None`.</span>
<span class="sd">            validation_steps: Number of steps to run validation for</span>
<span class="sd">                (only if doing validation from data tensors).</span>
<span class="sd">                Ignored with the default value of `None`.</span>

<span class="sd">        # Returns</span>
<span class="sd">            `History` object.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">do_validation</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">if</span> <span class="n">val_f</span> <span class="ow">and</span> <span class="n">val_ins</span><span class="p">:</span>
            <span class="n">do_validation</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="k">if</span> <span class="n">verbose</span> <span class="ow">and</span> <span class="n">ins</span> <span class="ow">and</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">ins</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="s1">&#39;shape&#39;</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">val_ins</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="s1">&#39;shape&#39;</span><span class="p">):</span>
                <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Train on </span><span class="si">%d</span><span class="s1"> samples, validate on </span><span class="si">%d</span><span class="s1"> samples&#39;</span> <span class="o">%</span>
                      <span class="p">(</span><span class="n">ins</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">val_ins</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>
        <span class="k">if</span> <span class="n">validation_steps</span><span class="p">:</span>
            <span class="n">do_validation</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="k">if</span> <span class="n">steps_per_epoch</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Can only use `validation_steps` &#39;</span>
                                 <span class="s1">&#39;when doing step-wise &#39;</span>
                                 <span class="s1">&#39;training, i.e. `steps_per_epoch` &#39;</span>
                                 <span class="s1">&#39;must be set.&#39;</span><span class="p">)</span>

        <span class="n">num_train_samples</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_check_num_samples</span><span class="p">(</span><span class="n">ins</span><span class="p">,</span> <span class="n">batch_size</span><span class="p">,</span>
                                                    <span class="n">steps_per_epoch</span><span class="p">,</span>
                                                    <span class="s1">&#39;steps_per_epoch&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">num_train_samples</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">index_array</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">num_train_samples</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">history</span> <span class="o">=</span> <span class="n">cbks</span><span class="o">.</span><span class="n">History</span><span class="p">()</span>
        <span class="n">callbacks</span> <span class="o">=</span> <span class="p">[</span><span class="n">cbks</span><span class="o">.</span><span class="n">BaseLogger</span><span class="p">()]</span> <span class="o">+</span> <span class="p">(</span><span class="n">callbacks</span> <span class="ow">or</span> <span class="p">[])</span> <span class="o">+</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">history</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">steps_per_epoch</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">count_mode</span> <span class="o">=</span> <span class="s1">&#39;steps&#39;</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">count_mode</span> <span class="o">=</span> <span class="s1">&#39;samples&#39;</span>
            <span class="n">callbacks</span> <span class="o">+=</span> <span class="p">[</span><span class="n">cbks</span><span class="o">.</span><span class="n">ProgbarLogger</span><span class="p">(</span><span class="n">count_mode</span><span class="p">)]</span>
        <span class="n">callbacks</span> <span class="o">=</span> <span class="n">cbks</span><span class="o">.</span><span class="n">CallbackList</span><span class="p">(</span><span class="n">callbacks</span><span class="p">)</span>
        <span class="n">out_labels</span> <span class="o">=</span> <span class="n">out_labels</span> <span class="ow">or</span> <span class="p">[]</span>

        <span class="c1"># it&#39;s possible to callback a different model than self</span>
        <span class="c1"># (used by Sequential models)</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;callback_model&#39;</span><span class="p">)</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">callback_model</span><span class="p">:</span>
            <span class="n">callback_model</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">callback_model</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">callback_model</span> <span class="o">=</span> <span class="bp">self</span>

        <span class="n">callbacks</span><span class="o">.</span><span class="n">set_model</span><span class="p">(</span><span class="n">callback_model</span><span class="p">)</span>
        <span class="n">callbacks</span><span class="o">.</span><span class="n">set_params</span><span class="p">({</span>
            <span class="s1">&#39;batch_size&#39;</span><span class="p">:</span> <span class="n">batch_size</span><span class="p">,</span>
            <span class="s1">&#39;epochs&#39;</span><span class="p">:</span> <span class="n">epochs</span><span class="p">,</span>
            <span class="s1">&#39;steps&#39;</span><span class="p">:</span> <span class="n">steps_per_epoch</span><span class="p">,</span>
            <span class="s1">&#39;samples&#39;</span><span class="p">:</span> <span class="n">num_train_samples</span><span class="p">,</span>
            <span class="s1">&#39;verbose&#39;</span><span class="p">:</span> <span class="n">verbose</span><span class="p">,</span>
            <span class="s1">&#39;do_validation&#39;</span><span class="p">:</span> <span class="n">do_validation</span><span class="p">,</span>
            <span class="s1">&#39;metrics&#39;</span><span class="p">:</span> <span class="n">callback_metrics</span> <span class="ow">or</span> <span class="p">[],</span>
        <span class="p">})</span>
        <span class="n">callbacks</span><span class="o">.</span><span class="n">on_train_begin</span><span class="p">()</span>
        <span class="n">callback_model</span><span class="o">.</span><span class="n">stop_training</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">for</span> <span class="n">cbk</span> <span class="ow">in</span> <span class="n">callbacks</span><span class="p">:</span>
            <span class="n">cbk</span><span class="o">.</span><span class="n">validation_data</span> <span class="o">=</span> <span class="n">val_ins</span>

        <span class="k">for</span> <span class="n">epoch</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">initial_epoch</span><span class="p">,</span> <span class="n">epochs</span><span class="p">):</span>
            <span class="n">callbacks</span><span class="o">.</span><span class="n">on_epoch_begin</span><span class="p">(</span><span class="n">epoch</span><span class="p">)</span>
            <span class="n">epoch_logs</span> <span class="o">=</span> <span class="p">{}</span>
            <span class="k">if</span> <span class="n">steps_per_epoch</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">step_index</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">steps_per_epoch</span><span class="p">):</span>
                    <span class="n">batch_logs</span> <span class="o">=</span> <span class="p">{}</span>
                    <span class="n">batch_logs</span><span class="p">[</span><span class="s1">&#39;batch&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">step_index</span>
                    <span class="n">batch_logs</span><span class="p">[</span><span class="s1">&#39;size&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
                    <span class="n">callbacks</span><span class="o">.</span><span class="n">on_batch_begin</span><span class="p">(</span><span class="n">step_index</span><span class="p">,</span> <span class="n">batch_logs</span><span class="p">)</span>
                    <span class="n">outs</span> <span class="o">=</span> <span class="n">f</span><span class="p">(</span><span class="n">ins</span><span class="p">)</span>

                    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">outs</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
                        <span class="n">outs</span> <span class="o">=</span> <span class="p">[</span><span class="n">outs</span><span class="p">]</span>
                    <span class="k">for</span> <span class="n">l</span><span class="p">,</span> <span class="n">o</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">out_labels</span><span class="p">,</span> <span class="n">outs</span><span class="p">):</span>
                        <span class="n">batch_logs</span><span class="p">[</span><span class="n">l</span><span class="p">]</span> <span class="o">=</span> <span class="n">o</span>

                    <span class="n">callbacks</span><span class="o">.</span><span class="n">on_batch_end</span><span class="p">(</span><span class="n">step_index</span><span class="p">,</span> <span class="n">batch_logs</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">callback_model</span><span class="o">.</span><span class="n">stop_training</span><span class="p">:</span>
                        <span class="k">break</span>

                <span class="k">if</span> <span class="n">do_validation</span><span class="p">:</span>
                    <span class="n">val_outs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_test_loop</span><span class="p">(</span><span class="n">val_f</span><span class="p">,</span> <span class="n">val_ins</span><span class="p">,</span>
                                               <span class="n">batch_size</span><span class="o">=</span><span class="n">batch_size</span><span class="p">,</span>
                                               <span class="n">steps</span><span class="o">=</span><span class="n">validation_steps</span><span class="p">,</span>
                                               <span class="n">verbose</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
                    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">val_outs</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
                        <span class="n">val_outs</span> <span class="o">=</span> <span class="p">[</span><span class="n">val_outs</span><span class="p">]</span>
                    <span class="c1"># Same labels assumed.</span>
                    <span class="k">for</span> <span class="n">l</span><span class="p">,</span> <span class="n">o</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">out_labels</span><span class="p">,</span> <span class="n">val_outs</span><span class="p">):</span>
                        <span class="n">epoch_logs</span><span class="p">[</span><span class="s1">&#39;val_&#39;</span> <span class="o">+</span> <span class="n">l</span><span class="p">]</span> <span class="o">=</span> <span class="n">o</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">shuffle</span> <span class="o">==</span> <span class="s1">&#39;batch&#39;</span><span class="p">:</span>
                    <span class="n">index_array</span> <span class="o">=</span> <span class="n">_batch_shuffle</span><span class="p">(</span><span class="n">index_array</span><span class="p">,</span> <span class="n">batch_size</span><span class="p">)</span>
                <span class="k">elif</span> <span class="n">shuffle</span><span class="p">:</span>
                    <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">shuffle</span><span class="p">(</span><span class="n">index_array</span><span class="p">)</span>

                <span class="n">batches</span> <span class="o">=</span> <span class="n">_make_batches</span><span class="p">(</span><span class="n">num_train_samples</span><span class="p">,</span> <span class="n">batch_size</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">batch_index</span><span class="p">,</span> <span class="p">(</span><span class="n">batch_start</span><span class="p">,</span> <span class="n">batch_end</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">batches</span><span class="p">):</span>
                    <span class="n">batch_ids</span> <span class="o">=</span> <span class="n">index_array</span><span class="p">[</span><span class="n">batch_start</span><span class="p">:</span><span class="n">batch_end</span><span class="p">]</span>
                    <span class="k">try</span><span class="p">:</span>
                        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">ins</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="nb">float</span><span class="p">):</span>
                            <span class="c1"># Do not slice the training phase flag.</span>
                            <span class="n">ins_batch</span> <span class="o">=</span> <span class="n">_slice_arrays</span><span class="p">(</span><span class="n">ins</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">batch_ids</span><span class="p">)</span> <span class="o">+</span> <span class="p">[</span><span class="n">ins</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]]</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="n">ins_batch</span> <span class="o">=</span> <span class="n">_slice_arrays</span><span class="p">(</span><span class="n">ins</span><span class="p">,</span> <span class="n">batch_ids</span><span class="p">)</span>
                    <span class="k">except</span> <span class="ne">TypeError</span><span class="p">:</span>
                        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;TypeError while preparing batch. &#39;</span>
                                        <span class="s1">&#39;If using HDF5 input data, &#39;</span>
                                        <span class="s1">&#39;pass shuffle=&quot;batch&quot;.&#39;</span><span class="p">)</span>
                    <span class="n">batch_logs</span> <span class="o">=</span> <span class="p">{}</span>
                    <span class="n">batch_logs</span><span class="p">[</span><span class="s1">&#39;batch&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">batch_index</span>
                    <span class="n">batch_logs</span><span class="p">[</span><span class="s1">&#39;size&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">batch_ids</span><span class="p">)</span>
                    <span class="n">callbacks</span><span class="o">.</span><span class="n">on_batch_begin</span><span class="p">(</span><span class="n">batch_index</span><span class="p">,</span> <span class="n">batch_logs</span><span class="p">)</span>
                    <span class="n">outs</span> <span class="o">=</span> <span class="n">f</span><span class="p">(</span><span class="n">ins_batch</span><span class="p">)</span>
                    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">outs</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
                        <span class="n">outs</span> <span class="o">=</span> <span class="p">[</span><span class="n">outs</span><span class="p">]</span>
                    <span class="k">for</span> <span class="n">l</span><span class="p">,</span> <span class="n">o</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">out_labels</span><span class="p">,</span> <span class="n">outs</span><span class="p">):</span>
                        <span class="n">batch_logs</span><span class="p">[</span><span class="n">l</span><span class="p">]</span> <span class="o">=</span> <span class="n">o</span>

                    <span class="n">callbacks</span><span class="o">.</span><span class="n">on_batch_end</span><span class="p">(</span><span class="n">batch_index</span><span class="p">,</span> <span class="n">batch_logs</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">callback_model</span><span class="o">.</span><span class="n">stop_training</span><span class="p">:</span>
                        <span class="k">break</span>

                    <span class="k">if</span> <span class="n">batch_index</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">batches</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span>  <span class="c1"># Last batch.</span>
                        <span class="k">if</span> <span class="n">do_validation</span><span class="p">:</span>
                            <span class="n">val_outs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_test_loop</span><span class="p">(</span><span class="n">val_f</span><span class="p">,</span> <span class="n">val_ins</span><span class="p">,</span>
                                                       <span class="n">batch_size</span><span class="o">=</span><span class="n">batch_size</span><span class="p">,</span>
                                                       <span class="n">verbose</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
                            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">val_outs</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
                                <span class="n">val_outs</span> <span class="o">=</span> <span class="p">[</span><span class="n">val_outs</span><span class="p">]</span>
                            <span class="c1"># Same labels assumed.</span>
                            <span class="k">for</span> <span class="n">l</span><span class="p">,</span> <span class="n">o</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">out_labels</span><span class="p">,</span> <span class="n">val_outs</span><span class="p">):</span>
                                <span class="n">epoch_logs</span><span class="p">[</span><span class="s1">&#39;val_&#39;</span> <span class="o">+</span> <span class="n">l</span><span class="p">]</span> <span class="o">=</span> <span class="n">o</span>
            <span class="n">callbacks</span><span class="o">.</span><span class="n">on_epoch_end</span><span class="p">(</span><span class="n">epoch</span><span class="p">,</span> <span class="n">epoch_logs</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">callback_model</span><span class="o">.</span><span class="n">stop_training</span><span class="p">:</span>
                <span class="k">break</span>
        <span class="n">callbacks</span><span class="o">.</span><span class="n">on_train_end</span><span class="p">()</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">history</span>

    <span class="k">def</span> <span class="nf">_predict_loop</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="n">ins</span><span class="p">,</span> <span class="n">batch_size</span><span class="o">=</span><span class="mi">32</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">steps</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Abstract method to loop over some data in batches.</span>

<span class="sd">        # Arguments</span>
<span class="sd">            f: Keras function returning a list of tensors.</span>
<span class="sd">            ins: list of tensors to be fed to `f`.</span>
<span class="sd">            batch_size: integer batch size.</span>
<span class="sd">            verbose: verbosity mode.</span>
<span class="sd">            steps: Total number of steps (batches of samples)</span>
<span class="sd">                before declaring `_predict_loop` finished.</span>
<span class="sd">                Ignored with the default value of `None`.</span>

<span class="sd">        # Returns</span>
<span class="sd">            Array of predictions (if the model has a single output)</span>
<span class="sd">            or list of arrays of predictions</span>
<span class="sd">            (if the model has multiple outputs).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">num_samples</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_check_num_samples</span><span class="p">(</span><span class="n">ins</span><span class="p">,</span> <span class="n">batch_size</span><span class="p">,</span>
                                              <span class="n">steps</span><span class="p">,</span>
                                              <span class="s1">&#39;steps&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">verbose</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">steps</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">progbar</span> <span class="o">=</span> <span class="n">Progbar</span><span class="p">(</span><span class="n">target</span><span class="o">=</span><span class="n">steps</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">progbar</span> <span class="o">=</span> <span class="n">Progbar</span><span class="p">(</span><span class="n">target</span><span class="o">=</span><span class="n">num_samples</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">steps</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># Step-based predictions.</span>
            <span class="c1"># Since we do not know how many samples</span>
            <span class="c1"># we will see, we cannot pre-allocate</span>
            <span class="c1"># the returned Numpy arrays.</span>
            <span class="c1"># Instead, we store one array per batch seen</span>
            <span class="c1"># and concatenate them upon returning.</span>
            <span class="n">unconcatenated_outs</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">step</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">steps</span><span class="p">):</span>
                <span class="n">batch_outs</span> <span class="o">=</span> <span class="n">f</span><span class="p">(</span><span class="n">ins</span><span class="p">)</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">batch_outs</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
                    <span class="n">batch_outs</span> <span class="o">=</span> <span class="p">[</span><span class="n">batch_outs</span><span class="p">]</span>
                <span class="k">if</span> <span class="n">step</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="k">for</span> <span class="n">batch_out</span> <span class="ow">in</span> <span class="n">batch_outs</span><span class="p">:</span>
                        <span class="n">unconcatenated_outs</span><span class="o">.</span><span class="n">append</span><span class="p">([])</span>
                <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">batch_out</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">batch_outs</span><span class="p">):</span>
                    <span class="n">unconcatenated_outs</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">batch_out</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">verbose</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="n">progbar</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">step</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">unconcatenated_outs</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span><span class="n">unconcatenated_outs</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
            <span class="k">return</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span><span class="n">unconcatenated_outs</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
                    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">unconcatenated_outs</span><span class="p">))]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Sample-based predictions.</span>
            <span class="n">outs</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">batches</span> <span class="o">=</span> <span class="n">_make_batches</span><span class="p">(</span><span class="n">num_samples</span><span class="p">,</span> <span class="n">batch_size</span><span class="p">)</span>
            <span class="n">index_array</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">num_samples</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">batch_index</span><span class="p">,</span> <span class="p">(</span><span class="n">batch_start</span><span class="p">,</span> <span class="n">batch_end</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">batches</span><span class="p">):</span>
                <span class="n">batch_ids</span> <span class="o">=</span> <span class="n">index_array</span><span class="p">[</span><span class="n">batch_start</span><span class="p">:</span><span class="n">batch_end</span><span class="p">]</span>
                <span class="k">if</span> <span class="n">ins</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">ins</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="nb">float</span><span class="p">):</span>
                    <span class="c1"># Do not slice the training phase flag.</span>
                    <span class="n">ins_batch</span> <span class="o">=</span> <span class="n">_slice_arrays</span><span class="p">(</span><span class="n">ins</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">batch_ids</span><span class="p">)</span> <span class="o">+</span> <span class="p">[</span><span class="n">ins</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]]</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">ins_batch</span> <span class="o">=</span> <span class="n">_slice_arrays</span><span class="p">(</span><span class="n">ins</span><span class="p">,</span> <span class="n">batch_ids</span><span class="p">)</span>
                <span class="n">batch_outs</span> <span class="o">=</span> <span class="n">f</span><span class="p">(</span><span class="n">ins_batch</span><span class="p">)</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">batch_outs</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
                    <span class="n">batch_outs</span> <span class="o">=</span> <span class="p">[</span><span class="n">batch_outs</span><span class="p">]</span>
                <span class="k">if</span> <span class="n">batch_index</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="c1"># Pre-allocate the results arrays.</span>
                    <span class="k">for</span> <span class="n">batch_out</span> <span class="ow">in</span> <span class="n">batch_outs</span><span class="p">:</span>
                        <span class="n">shape</span> <span class="o">=</span> <span class="p">(</span><span class="n">num_samples</span><span class="p">,)</span> <span class="o">+</span> <span class="n">batch_out</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>
                        <span class="n">outs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">shape</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">batch_out</span><span class="o">.</span><span class="n">dtype</span><span class="p">))</span>
                <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">batch_out</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">batch_outs</span><span class="p">):</span>
                    <span class="n">outs</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">batch_start</span><span class="p">:</span><span class="n">batch_end</span><span class="p">]</span> <span class="o">=</span> <span class="n">batch_out</span>
                <span class="k">if</span> <span class="n">verbose</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="n">progbar</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">batch_end</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">outs</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">outs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">return</span> <span class="n">outs</span>

    <span class="k">def</span> <span class="nf">_test_loop</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="n">ins</span><span class="p">,</span> <span class="n">batch_size</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">steps</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Abstract method to loop over some data in batches.</span>

<span class="sd">        # Arguments</span>
<span class="sd">            f: Keras function returning a list of tensors.</span>
<span class="sd">            ins: list of tensors to be fed to `f`.</span>
<span class="sd">            batch_size: integer batch size or `None`.</span>
<span class="sd">            verbose: verbosity mode.</span>
<span class="sd">            steps: Total number of steps (batches of samples)</span>
<span class="sd">                before declaring predictions finished.</span>
<span class="sd">                Ignored with the default value of `None`.</span>

<span class="sd">        # Returns</span>
<span class="sd">            Scalar loss (if the model has a single output and no metrics)</span>
<span class="sd">            or list of scalars (if the model has multiple outputs</span>
<span class="sd">            and/or metrics). The attribute `model.metrics_names` will give you</span>
<span class="sd">            the display labels for the scalar outputs.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">num_samples</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_check_num_samples</span><span class="p">(</span><span class="n">ins</span><span class="p">,</span> <span class="n">batch_size</span><span class="p">,</span>
                                              <span class="n">steps</span><span class="p">,</span>
                                              <span class="s1">&#39;steps&#39;</span><span class="p">)</span>
        <span class="n">outs</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">if</span> <span class="n">steps</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">verbose</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">progbar</span> <span class="o">=</span> <span class="n">Progbar</span><span class="p">(</span><span class="n">target</span><span class="o">=</span><span class="n">steps</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">step</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">steps</span><span class="p">):</span>
                <span class="n">batch_outs</span> <span class="o">=</span> <span class="n">f</span><span class="p">(</span><span class="n">ins</span><span class="p">)</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">batch_outs</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
                    <span class="k">if</span> <span class="n">step</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">batch_outs</span><span class="p">):</span>
                            <span class="n">outs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mf">0.</span><span class="p">)</span>
                    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">batch_out</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">batch_outs</span><span class="p">):</span>
                        <span class="n">outs</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+=</span> <span class="n">batch_out</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">step</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="n">outs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mf">0.</span><span class="p">)</span>
                    <span class="n">outs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+=</span> <span class="n">batch_outs</span>
                <span class="k">if</span> <span class="n">verbose</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="n">progbar</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">step</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">outs</span><span class="p">)):</span>
                <span class="n">outs</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">/=</span> <span class="n">steps</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">verbose</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">progbar</span> <span class="o">=</span> <span class="n">Progbar</span><span class="p">(</span><span class="n">target</span><span class="o">=</span><span class="n">num_samples</span><span class="p">)</span>
            <span class="n">batches</span> <span class="o">=</span> <span class="n">_make_batches</span><span class="p">(</span><span class="n">num_samples</span><span class="p">,</span> <span class="n">batch_size</span><span class="p">)</span>
            <span class="n">index_array</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">num_samples</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">batch_index</span><span class="p">,</span> <span class="p">(</span><span class="n">batch_start</span><span class="p">,</span> <span class="n">batch_end</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">batches</span><span class="p">):</span>
                <span class="n">batch_ids</span> <span class="o">=</span> <span class="n">index_array</span><span class="p">[</span><span class="n">batch_start</span><span class="p">:</span><span class="n">batch_end</span><span class="p">]</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">ins</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="nb">float</span><span class="p">):</span>
                    <span class="c1"># Do not slice the training phase flag.</span>
                    <span class="n">ins_batch</span> <span class="o">=</span> <span class="n">_slice_arrays</span><span class="p">(</span><span class="n">ins</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">batch_ids</span><span class="p">)</span> <span class="o">+</span> <span class="p">[</span><span class="n">ins</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]]</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">ins_batch</span> <span class="o">=</span> <span class="n">_slice_arrays</span><span class="p">(</span><span class="n">ins</span><span class="p">,</span> <span class="n">batch_ids</span><span class="p">)</span>

                <span class="n">batch_outs</span> <span class="o">=</span> <span class="n">f</span><span class="p">(</span><span class="n">ins_batch</span><span class="p">)</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">batch_outs</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
                    <span class="k">if</span> <span class="n">batch_index</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="k">for</span> <span class="n">batch_out</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">batch_outs</span><span class="p">):</span>
                            <span class="n">outs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mf">0.</span><span class="p">)</span>
                    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">batch_out</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">batch_outs</span><span class="p">):</span>
                        <span class="n">outs</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+=</span> <span class="n">batch_out</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">batch_ids</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">batch_index</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="n">outs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mf">0.</span><span class="p">)</span>
                    <span class="n">outs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+=</span> <span class="n">batch_outs</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">batch_ids</span><span class="p">)</span>

                <span class="k">if</span> <span class="n">verbose</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="n">progbar</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">batch_end</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">outs</span><span class="p">)):</span>
                <span class="n">outs</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">/=</span> <span class="n">num_samples</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">outs</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">outs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">outs</span>

    <span class="k">def</span> <span class="nf">_standardize_user_data</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span>
                               <span class="n">sample_weight</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">class_weight</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                               <span class="n">check_batch_axis</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">batch_size</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;optimizer&#39;</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s1">&#39;You must compile a model before &#39;</span>
                               <span class="s1">&#39;training/testing. &#39;</span>
                               <span class="s1">&#39;Use `model.compile(optimizer, loss)`.&#39;</span><span class="p">)</span>

        <span class="n">output_shapes</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">output_shape</span><span class="p">,</span> <span class="n">loss_fn</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_feed_output_shapes</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_feed_loss_fns</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">loss_fn</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">==</span> <span class="s1">&#39;sparse_categorical_crossentropy&#39;</span><span class="p">:</span>
                <span class="n">output_shapes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">output_shape</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="p">(</span><span class="mi">1</span><span class="p">,))</span>
            <span class="k">elif</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">losses</span><span class="p">,</span> <span class="n">loss_fn</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">output_shapes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">output_shapes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">output_shape</span><span class="p">)</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">_standardize_input_data</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_feed_input_names</span><span class="p">,</span>
                                    <span class="bp">self</span><span class="o">.</span><span class="n">_feed_input_shapes</span><span class="p">,</span>
                                    <span class="n">check_batch_axis</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                                    <span class="n">exception_prefix</span><span class="o">=</span><span class="s1">&#39;input&#39;</span><span class="p">)</span>
        <span class="n">y</span> <span class="o">=</span> <span class="n">_standardize_input_data</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_feed_output_names</span><span class="p">,</span>
                                    <span class="n">output_shapes</span><span class="p">,</span>
                                    <span class="n">check_batch_axis</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                                    <span class="n">exception_prefix</span><span class="o">=</span><span class="s1">&#39;target&#39;</span><span class="p">)</span>
        <span class="n">sample_weights</span> <span class="o">=</span> <span class="n">_standardize_sample_weights</span><span class="p">(</span><span class="n">sample_weight</span><span class="p">,</span>
                                                     <span class="bp">self</span><span class="o">.</span><span class="n">_feed_output_names</span><span class="p">)</span>
        <span class="n">class_weights</span> <span class="o">=</span> <span class="n">_standardize_class_weights</span><span class="p">(</span><span class="n">class_weight</span><span class="p">,</span>
                                                   <span class="bp">self</span><span class="o">.</span><span class="n">_feed_output_names</span><span class="p">)</span>
        <span class="n">sample_weights</span> <span class="o">=</span> <span class="p">[</span><span class="n">_standardize_weights</span><span class="p">(</span><span class="n">ref</span><span class="p">,</span> <span class="n">sw</span><span class="p">,</span> <span class="n">cw</span><span class="p">,</span> <span class="n">mode</span><span class="p">)</span>
                          <span class="k">for</span> <span class="p">(</span><span class="n">ref</span><span class="p">,</span> <span class="n">sw</span><span class="p">,</span> <span class="n">cw</span><span class="p">,</span> <span class="n">mode</span><span class="p">)</span>
                          <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">sample_weights</span><span class="p">,</span> <span class="n">class_weights</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_feed_sample_weight_modes</span><span class="p">)]</span>
        <span class="n">_check_array_lengths</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">sample_weights</span><span class="p">)</span>
        <span class="n">_check_loss_and_target_compatibility</span><span class="p">(</span><span class="n">y</span><span class="p">,</span>
                                             <span class="bp">self</span><span class="o">.</span><span class="n">_feed_loss_fns</span><span class="p">,</span>
                                             <span class="bp">self</span><span class="o">.</span><span class="n">_feed_output_shapes</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">stateful</span> <span class="ow">and</span> <span class="n">batch_size</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">%</span> <span class="n">batch_size</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;In a stateful network, &#39;</span>
                                 <span class="s1">&#39;you should only pass inputs with &#39;</span>
                                 <span class="s1">&#39;a number of samples that can be &#39;</span>
                                 <span class="s1">&#39;divided by the batch size. Found: &#39;</span> <span class="o">+</span>
                                 <span class="nb">str</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">+</span> <span class="s1">&#39; samples&#39;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">sample_weights</span>

    <span class="k">def</span> <span class="nf">_get_deduped_metrics_names</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">out_labels</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">metrics_names</span>

        <span class="c1"># Rename duplicated metrics name</span>
        <span class="c1"># (can happen with an output layer shared among multiple dataflows).</span>
        <span class="n">deduped_out_labels</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">label</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">out_labels</span><span class="p">):</span>
            <span class="n">new_label</span> <span class="o">=</span> <span class="n">label</span>
            <span class="k">if</span> <span class="n">out_labels</span><span class="o">.</span><span class="n">count</span><span class="p">(</span><span class="n">label</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">dup_idx</span> <span class="o">=</span> <span class="n">out_labels</span><span class="p">[:</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">count</span><span class="p">(</span><span class="n">label</span><span class="p">)</span>
                <span class="n">new_label</span> <span class="o">+=</span> <span class="s1">&#39;_&#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">dup_idx</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
            <span class="n">deduped_out_labels</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">new_label</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">deduped_out_labels</span>

    <span class="k">def</span> <span class="nf">fit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
            <span class="n">y</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
            <span class="n">batch_size</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
            <span class="n">epochs</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
            <span class="n">verbose</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
            <span class="n">callbacks</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
            <span class="n">validation_split</span><span class="o">=</span><span class="mf">0.</span><span class="p">,</span>
            <span class="n">validation_data</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
            <span class="n">shuffle</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
            <span class="n">class_weight</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
            <span class="n">sample_weight</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
            <span class="n">initial_epoch</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
            <span class="n">steps_per_epoch</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
            <span class="n">validation_steps</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
            <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Trains the model for a fixed number of epochs (iterations on a dataset).</span>

<span class="sd">        # Arguments</span>
<span class="sd">            x: Numpy array of training data,</span>
<span class="sd">                or list of Numpy arrays if the model has multiple inputs.</span>
<span class="sd">                If all inputs in the model are named,</span>
<span class="sd">                you can also pass a dictionary</span>
<span class="sd">                mapping input names to Numpy arrays.</span>
<span class="sd">            y: Numpy array of target data,</span>
<span class="sd">                or list of Numpy arrays if the model has multiple outputs.</span>
<span class="sd">                If all outputs in the model are named,</span>
<span class="sd">                you can also pass a dictionary</span>
<span class="sd">                mapping output names to Numpy arrays.</span>
<span class="sd">            batch_size: Integer or `None`.</span>
<span class="sd">                Number of samples per gradient update.</span>
<span class="sd">                If unspecified, it will default to 32.</span>
<span class="sd">            epochs: Integer, the number of times to iterate</span>
<span class="sd">                over the training data arrays.</span>
<span class="sd">            verbose: 0, 1, or 2. Verbosity mode.</span>
<span class="sd">                0 = silent, 1 = verbose, 2 = one log line per epoch.</span>
<span class="sd">            callbacks: List of callbacks to be called during training.</span>
<span class="sd">                See [callbacks](/callbacks).</span>
<span class="sd">            validation_split: Float between 0 and 1:</span>
<span class="sd">                fraction of the training data to be used as validation data.</span>
<span class="sd">                The model will set apart this fraction of the training data,</span>
<span class="sd">                will not train on it, and will evaluate</span>
<span class="sd">                the loss and any model metrics</span>
<span class="sd">                on this data at the end of each epoch.</span>
<span class="sd">            validation_data: Data on which to evaluate</span>
<span class="sd">                the loss and any model metrics</span>
<span class="sd">                at the end of each epoch. The model will not</span>
<span class="sd">                be trained on this data.</span>
<span class="sd">                This could be a tuple (x_val, y_val)</span>
<span class="sd">                or a tuple (x_val, y_val, val_sample_weights).</span>
<span class="sd">            shuffle: Boolean, whether to shuffle the training data</span>
<span class="sd">                before each epoch. Has no effect when `steps_per_epoch`</span>
<span class="sd">                is not `None`.</span>
<span class="sd">            class_weight: Optional dictionary mapping</span>
<span class="sd">                class indices (integers) to</span>
<span class="sd">                a weight (float) to apply to the model&#39;s loss for the samples</span>
<span class="sd">                from this class during training.</span>
<span class="sd">                This can be useful to tell the model to &quot;pay more attention&quot; to</span>
<span class="sd">                samples from an under-represented class.</span>
<span class="sd">            sample_weight: Optional array of the same length as x, containing</span>
<span class="sd">                weights to apply to the model&#39;s loss for each sample.</span>
<span class="sd">                In the case of temporal data, you can pass a 2D array</span>
<span class="sd">                with shape (samples, sequence_length),</span>
<span class="sd">                to apply a different weight to every timestep of every sample.</span>
<span class="sd">                In this case you should make sure to specify</span>
<span class="sd">                sample_weight_mode=&quot;temporal&quot; in compile().</span>
<span class="sd">            initial_epoch: Epoch at which to start training</span>
<span class="sd">                (useful for resuming a previous training run)</span>
<span class="sd">            steps_per_epoch: Total number of steps (batches of samples)</span>
<span class="sd">                before declaring one epoch finished and starting the</span>
<span class="sd">                next epoch. When training with Input Tensors such as</span>
<span class="sd">                TensorFlow data tensors, the default `None` is equal to</span>
<span class="sd">                the number of unique samples in your dataset divided by</span>
<span class="sd">                the batch size, or 1 if that cannot be determined.</span>
<span class="sd">            validation_steps: Only relevant if `steps_per_epoch`</span>
<span class="sd">                is specified. Total number of steps (batches of samples)</span>
<span class="sd">                to validate before stopping.</span>

<span class="sd">        # Returns</span>
<span class="sd">            A `History` instance. Its `history` attribute contains</span>
<span class="sd">            all information collected during training.</span>

<span class="sd">        # Raises</span>
<span class="sd">            ValueError: In case of mismatch between the provided input data</span>
<span class="sd">                and what the model expects.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Backwards compatibility</span>
        <span class="k">if</span> <span class="n">batch_size</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">steps_per_epoch</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">batch_size</span> <span class="o">=</span> <span class="mi">32</span>
        <span class="c1"># Legacy support</span>
        <span class="k">if</span> <span class="s1">&#39;nb_epoch&#39;</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">:</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s1">&#39;The `nb_epoch` argument in `fit` &#39;</span>
                          <span class="s1">&#39;has been renamed `epochs`.&#39;</span><span class="p">,</span> <span class="n">stacklevel</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
            <span class="n">epochs</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;nb_epoch&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">kwargs</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;Unrecognized keyword arguments: &#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">kwargs</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">x</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">y</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">steps_per_epoch</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;If fitting from data tensors, &#39;</span>
                             <span class="s1">&#39;you should specify the `steps_per_epoch` &#39;</span>
                             <span class="s1">&#39;argument.&#39;</span><span class="p">)</span>
        <span class="c1"># Validate user data.</span>
        <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">sample_weights</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_standardize_user_data</span><span class="p">(</span>
            <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span>
            <span class="n">sample_weight</span><span class="o">=</span><span class="n">sample_weight</span><span class="p">,</span>
            <span class="n">class_weight</span><span class="o">=</span><span class="n">class_weight</span><span class="p">,</span>
            <span class="n">check_batch_axis</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
            <span class="n">batch_size</span><span class="o">=</span><span class="n">batch_size</span><span class="p">)</span>
        <span class="c1"># Prepare validation data.</span>
        <span class="n">do_validation</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">if</span> <span class="n">validation_data</span><span class="p">:</span>
            <span class="n">do_validation</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">validation_data</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
                <span class="n">val_x</span><span class="p">,</span> <span class="n">val_y</span> <span class="o">=</span> <span class="n">validation_data</span>
                <span class="n">val_sample_weight</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">validation_data</span><span class="p">)</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
                <span class="n">val_x</span><span class="p">,</span> <span class="n">val_y</span><span class="p">,</span> <span class="n">val_sample_weight</span> <span class="o">=</span> <span class="n">validation_data</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;When passing validation_data, &#39;</span>
                                 <span class="s1">&#39;it must contain 2 (x_val, y_val) &#39;</span>
                                 <span class="s1">&#39;or 3 (x_val, y_val, val_sample_weights) &#39;</span>
                                 <span class="s1">&#39;items, however it contains </span><span class="si">%d</span><span class="s1"> items&#39;</span> <span class="o">%</span>
                                 <span class="nb">len</span><span class="p">(</span><span class="n">validation_data</span><span class="p">))</span>

            <span class="n">val_x</span><span class="p">,</span> <span class="n">val_y</span><span class="p">,</span> <span class="n">val_sample_weights</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_standardize_user_data</span><span class="p">(</span>
                <span class="n">val_x</span><span class="p">,</span> <span class="n">val_y</span><span class="p">,</span>
                <span class="n">sample_weight</span><span class="o">=</span><span class="n">val_sample_weight</span><span class="p">,</span>
                <span class="n">check_batch_axis</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                <span class="n">batch_size</span><span class="o">=</span><span class="n">batch_size</span><span class="p">)</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">uses_learning_phase</span> <span class="ow">and</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">K</span><span class="o">.</span><span class="n">learning_phase</span><span class="p">(),</span> <span class="nb">int</span><span class="p">):</span>
                <span class="n">val_ins</span> <span class="o">=</span> <span class="n">val_x</span> <span class="o">+</span> <span class="n">val_y</span> <span class="o">+</span> <span class="n">val_sample_weights</span> <span class="o">+</span> <span class="p">[</span><span class="mf">0.</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">val_ins</span> <span class="o">=</span> <span class="n">val_x</span> <span class="o">+</span> <span class="n">val_y</span> <span class="o">+</span> <span class="n">val_sample_weights</span>

        <span class="k">elif</span> <span class="n">validation_split</span> <span class="ow">and</span> <span class="mf">0.</span> <span class="o">&lt;</span> <span class="n">validation_split</span> <span class="o">&lt;</span> <span class="mf">1.</span><span class="p">:</span>
            <span class="n">do_validation</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="s1">&#39;shape&#39;</span><span class="p">):</span>
                <span class="n">split_at</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="mf">1.</span> <span class="o">-</span> <span class="n">validation_split</span><span class="p">))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">split_at</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">*</span> <span class="p">(</span><span class="mf">1.</span> <span class="o">-</span> <span class="n">validation_split</span><span class="p">))</span>
            <span class="n">x</span><span class="p">,</span> <span class="n">val_x</span> <span class="o">=</span> <span class="p">(</span><span class="n">_slice_arrays</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">split_at</span><span class="p">),</span> <span class="n">_slice_arrays</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">split_at</span><span class="p">))</span>
            <span class="n">y</span><span class="p">,</span> <span class="n">val_y</span> <span class="o">=</span> <span class="p">(</span><span class="n">_slice_arrays</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">split_at</span><span class="p">),</span> <span class="n">_slice_arrays</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">split_at</span><span class="p">))</span>
            <span class="n">sample_weights</span><span class="p">,</span> <span class="n">val_sample_weights</span> <span class="o">=</span> <span class="p">(</span>
                <span class="n">_slice_arrays</span><span class="p">(</span><span class="n">sample_weights</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">split_at</span><span class="p">),</span>
                <span class="n">_slice_arrays</span><span class="p">(</span><span class="n">sample_weights</span><span class="p">,</span> <span class="n">split_at</span><span class="p">))</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">uses_learning_phase</span> <span class="ow">and</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">K</span><span class="o">.</span><span class="n">learning_phase</span><span class="p">(),</span> <span class="nb">int</span><span class="p">):</span>
                <span class="n">val_ins</span> <span class="o">=</span> <span class="n">val_x</span> <span class="o">+</span> <span class="n">val_y</span> <span class="o">+</span> <span class="n">val_sample_weights</span> <span class="o">+</span> <span class="p">[</span><span class="mf">0.</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">val_ins</span> <span class="o">=</span> <span class="n">val_x</span> <span class="o">+</span> <span class="n">val_y</span> <span class="o">+</span> <span class="n">val_sample_weights</span>

        <span class="k">elif</span> <span class="n">validation_steps</span><span class="p">:</span>
            <span class="n">do_validation</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">uses_learning_phase</span> <span class="ow">and</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">K</span><span class="o">.</span><span class="n">learning_phase</span><span class="p">(),</span> <span class="nb">int</span><span class="p">):</span>
                <span class="n">val_ins</span> <span class="o">=</span> <span class="p">[</span><span class="mf">0.</span><span class="p">]</span>

        <span class="c1"># Prepare input arrays and training function.</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">uses_learning_phase</span> <span class="ow">and</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">K</span><span class="o">.</span><span class="n">learning_phase</span><span class="p">(),</span> <span class="nb">int</span><span class="p">):</span>
            <span class="n">ins</span> <span class="o">=</span> <span class="n">x</span> <span class="o">+</span> <span class="n">y</span> <span class="o">+</span> <span class="n">sample_weights</span> <span class="o">+</span> <span class="p">[</span><span class="mf">1.</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">ins</span> <span class="o">=</span> <span class="n">x</span> <span class="o">+</span> <span class="n">y</span> <span class="o">+</span> <span class="n">sample_weights</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_make_train_function</span><span class="p">()</span>
        <span class="n">f</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">train_function</span>

        <span class="c1"># Prepare display labels.</span>
        <span class="n">out_labels</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_deduped_metrics_names</span><span class="p">()</span>

        <span class="k">if</span> <span class="n">do_validation</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_make_test_function</span><span class="p">()</span>
            <span class="n">val_f</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">test_function</span>
            <span class="n">callback_metrics</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">out_labels</span><span class="p">)</span> <span class="o">+</span> <span class="p">[</span><span class="s1">&#39;val_&#39;</span> <span class="o">+</span> <span class="n">n</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">out_labels</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">callback_metrics</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">out_labels</span><span class="p">)</span>
            <span class="n">val_f</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="n">val_ins</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="c1"># Delegate logic to `_fit_loop`.</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_fit_loop</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">ins</span><span class="p">,</span> <span class="n">out_labels</span><span class="o">=</span><span class="n">out_labels</span><span class="p">,</span>
                              <span class="n">batch_size</span><span class="o">=</span><span class="n">batch_size</span><span class="p">,</span> <span class="n">epochs</span><span class="o">=</span><span class="n">epochs</span><span class="p">,</span>
                              <span class="n">verbose</span><span class="o">=</span><span class="n">verbose</span><span class="p">,</span> <span class="n">callbacks</span><span class="o">=</span><span class="n">callbacks</span><span class="p">,</span>
                              <span class="n">val_f</span><span class="o">=</span><span class="n">val_f</span><span class="p">,</span> <span class="n">val_ins</span><span class="o">=</span><span class="n">val_ins</span><span class="p">,</span> <span class="n">shuffle</span><span class="o">=</span><span class="n">shuffle</span><span class="p">,</span>
                              <span class="n">callback_metrics</span><span class="o">=</span><span class="n">callback_metrics</span><span class="p">,</span>
                              <span class="n">initial_epoch</span><span class="o">=</span><span class="n">initial_epoch</span><span class="p">,</span>
                              <span class="n">steps_per_epoch</span><span class="o">=</span><span class="n">steps_per_epoch</span><span class="p">,</span>
                              <span class="n">validation_steps</span><span class="o">=</span><span class="n">validation_steps</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">evaluate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span>
                 <span class="n">batch_size</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">verbose</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
                 <span class="n">sample_weight</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">steps</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns the loss value &amp; metrics values for the model in test mode.</span>

<span class="sd">        Computation is done in batches.</span>

<span class="sd">        # Arguments</span>
<span class="sd">            x: Numpy array of test data,</span>
<span class="sd">                or list of Numpy arrays if the model has multiple inputs.</span>
<span class="sd">                If all inputs in the model are named,</span>
<span class="sd">                you can also pass a dictionary</span>
<span class="sd">                mapping input names to Numpy arrays.</span>
<span class="sd">            y: Numpy array of target data,</span>
<span class="sd">                or list of Numpy arrays if the model has multiple outputs.</span>
<span class="sd">                If all outputs in the model are named,</span>
<span class="sd">                you can also pass a dictionary</span>
<span class="sd">                mapping output names to Numpy arrays.</span>
<span class="sd">            batch_size: Integer. If unspecified, it will default to 32.</span>
<span class="sd">            verbose: Verbosity mode, 0 or 1.</span>
<span class="sd">            sample_weight: Array of weights to weight the contribution</span>
<span class="sd">                of different samples to the loss and metrics.</span>
<span class="sd">            steps: Total number of steps (batches of samples)</span>
<span class="sd">                before declaring the evaluation round finished.</span>
<span class="sd">                Ignored with the default value of `None`.</span>

<span class="sd">        # Returns</span>
<span class="sd">            Scalar test loss (if the model has a single output and no metrics)</span>
<span class="sd">            or list of scalars (if the model has multiple outputs</span>
<span class="sd">            and/or metrics). The attribute `model.metrics_names` will give you</span>
<span class="sd">            the display labels for the scalar outputs.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Backwards compatibility.</span>
        <span class="k">if</span> <span class="n">batch_size</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">steps</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">batch_size</span> <span class="o">=</span> <span class="mi">32</span>
        <span class="k">if</span> <span class="n">x</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">y</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">steps</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;If evaluating from data tensors, &#39;</span>
                             <span class="s1">&#39;you should specify the `steps` &#39;</span>
                             <span class="s1">&#39;argument.&#39;</span><span class="p">)</span>
        <span class="c1"># Validate user data.</span>
        <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">sample_weights</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_standardize_user_data</span><span class="p">(</span>
            <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span>
            <span class="n">sample_weight</span><span class="o">=</span><span class="n">sample_weight</span><span class="p">,</span>
            <span class="n">check_batch_axis</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
            <span class="n">batch_size</span><span class="o">=</span><span class="n">batch_size</span><span class="p">)</span>
        <span class="c1"># Prepare inputs, delegate logic to `_test_loop`.</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">uses_learning_phase</span> <span class="ow">and</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">K</span><span class="o">.</span><span class="n">learning_phase</span><span class="p">(),</span> <span class="nb">int</span><span class="p">):</span>
            <span class="n">ins</span> <span class="o">=</span> <span class="n">x</span> <span class="o">+</span> <span class="n">y</span> <span class="o">+</span> <span class="n">sample_weights</span> <span class="o">+</span> <span class="p">[</span><span class="mf">0.</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">ins</span> <span class="o">=</span> <span class="n">x</span> <span class="o">+</span> <span class="n">y</span> <span class="o">+</span> <span class="n">sample_weights</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_make_test_function</span><span class="p">()</span>
        <span class="n">f</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">test_function</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_test_loop</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">ins</span><span class="p">,</span>
                               <span class="n">batch_size</span><span class="o">=</span><span class="n">batch_size</span><span class="p">,</span>
                               <span class="n">verbose</span><span class="o">=</span><span class="n">verbose</span><span class="p">,</span>
                               <span class="n">steps</span><span class="o">=</span><span class="n">steps</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">predict</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span>
                <span class="n">batch_size</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                <span class="n">verbose</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
                <span class="n">steps</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Generates output predictions for the input samples.</span>

<span class="sd">        Computation is done in batches.</span>

<span class="sd">        # Arguments</span>
<span class="sd">            x: The input data, as a Numpy array</span>
<span class="sd">                (or list of Numpy arrays if the model has multiple outputs).</span>
<span class="sd">            batch_size: Integer. If unspecified, it will default to 32.</span>
<span class="sd">            verbose: Verbosity mode, 0 or 1.</span>
<span class="sd">            steps: Total number of steps (batches of samples)</span>
<span class="sd">                before declaring the prediction round finished.</span>
<span class="sd">                Ignored with the default value of `None`.</span>

<span class="sd">        # Returns</span>
<span class="sd">            Numpy array(s) of predictions.</span>

<span class="sd">        # Raises</span>
<span class="sd">            ValueError: In case of mismatch between the provided</span>
<span class="sd">                input data and the model&#39;s expectations,</span>
<span class="sd">                or in case a stateful model receives a number of samples</span>
<span class="sd">                that is not a multiple of the batch size.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Backwards compatibility.</span>
        <span class="k">if</span> <span class="n">batch_size</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">steps</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">batch_size</span> <span class="o">=</span> <span class="mi">32</span>
        <span class="k">if</span> <span class="n">x</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">steps</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;If predicting from data tensors, &#39;</span>
                             <span class="s1">&#39;you should specify the `steps` &#39;</span>
                             <span class="s1">&#39;argument.&#39;</span><span class="p">)</span>
        <span class="c1"># Validate user data.</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">_standardize_input_data</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_feed_input_names</span><span class="p">,</span>
                                    <span class="bp">self</span><span class="o">.</span><span class="n">_feed_input_shapes</span><span class="p">,</span>
                                    <span class="n">check_batch_axis</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">stateful</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">batch_size</span> <span class="ow">and</span> <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">%</span> <span class="n">batch_size</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;In a stateful network, &#39;</span>
                                 <span class="s1">&#39;you should only pass inputs with &#39;</span>
                                 <span class="s1">&#39;a number of samples that can be &#39;</span>
                                 <span class="s1">&#39;divided by the batch size. Found: &#39;</span> <span class="o">+</span>
                                 <span class="nb">str</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">+</span> <span class="s1">&#39; samples. &#39;</span>
                                 <span class="s1">&#39;Batch size: &#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">batch_size</span><span class="p">)</span> <span class="o">+</span> <span class="s1">&#39;.&#39;</span><span class="p">)</span>

        <span class="c1"># Prepare inputs, delegate logic to `_predict_loop`.</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">uses_learning_phase</span> <span class="ow">and</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">K</span><span class="o">.</span><span class="n">learning_phase</span><span class="p">(),</span> <span class="nb">int</span><span class="p">):</span>
            <span class="n">ins</span> <span class="o">=</span> <span class="n">x</span> <span class="o">+</span> <span class="p">[</span><span class="mf">0.</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">ins</span> <span class="o">=</span> <span class="n">x</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_make_predict_function</span><span class="p">()</span>
        <span class="n">f</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">predict_function</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_predict_loop</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">ins</span><span class="p">,</span> <span class="n">batch_size</span><span class="o">=</span><span class="n">batch_size</span><span class="p">,</span>
                                  <span class="n">verbose</span><span class="o">=</span><span class="n">verbose</span><span class="p">,</span> <span class="n">steps</span><span class="o">=</span><span class="n">steps</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">train_on_batch</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span>
                       <span class="n">sample_weight</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                       <span class="n">class_weight</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Runs a single gradient update on a single batch of data.</span>

<span class="sd">        # Arguments</span>
<span class="sd">            x: Numpy array of training data,</span>
<span class="sd">                or list of Numpy arrays if the model has multiple inputs.</span>
<span class="sd">                If all inputs in the model are named,</span>
<span class="sd">                you can also pass a dictionary</span>
<span class="sd">                mapping input names to Numpy arrays.</span>
<span class="sd">            y: Numpy array of target data,</span>
<span class="sd">                or list of Numpy arrays if the model has multiple outputs.</span>
<span class="sd">                If all outputs in the model are named,</span>
<span class="sd">                you can also pass a dictionary</span>
<span class="sd">                mapping output names to Numpy arrays.</span>
<span class="sd">            sample_weight: Optional array of the same length as x, containing</span>
<span class="sd">                weights to apply to the model&#39;s loss for each sample.</span>
<span class="sd">                In the case of temporal data, you can pass a 2D array</span>
<span class="sd">                with shape (samples, sequence_length),</span>
<span class="sd">                to apply a different weight to every timestep of every sample.</span>
<span class="sd">                In this case you should make sure to specify</span>
<span class="sd">                sample_weight_mode=&quot;temporal&quot; in compile().</span>
<span class="sd">            class_weight: Optional dictionary mapping</span>
<span class="sd">                class indices (integers) to</span>
<span class="sd">                a weight (float) to apply to the model&#39;s loss for the samples</span>
<span class="sd">                from this class during training.</span>
<span class="sd">                This can be useful to tell the model to &quot;pay more attention&quot; to</span>
<span class="sd">                samples from an under-represented class.</span>

<span class="sd">        # Returns</span>
<span class="sd">            Scalar training loss</span>
<span class="sd">            (if the model has a single output and no metrics)</span>
<span class="sd">            or list of scalars (if the model has multiple outputs</span>
<span class="sd">            and/or metrics). The attribute `model.metrics_names` will give you</span>
<span class="sd">            the display labels for the scalar outputs.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">sample_weights</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_standardize_user_data</span><span class="p">(</span>
            <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span>
            <span class="n">sample_weight</span><span class="o">=</span><span class="n">sample_weight</span><span class="p">,</span>
            <span class="n">class_weight</span><span class="o">=</span><span class="n">class_weight</span><span class="p">,</span>
            <span class="n">check_batch_axis</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">uses_learning_phase</span> <span class="ow">and</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">K</span><span class="o">.</span><span class="n">learning_phase</span><span class="p">(),</span> <span class="nb">int</span><span class="p">):</span>
            <span class="n">ins</span> <span class="o">=</span> <span class="n">x</span> <span class="o">+</span> <span class="n">y</span> <span class="o">+</span> <span class="n">sample_weights</span> <span class="o">+</span> <span class="p">[</span><span class="mf">1.</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">ins</span> <span class="o">=</span> <span class="n">x</span> <span class="o">+</span> <span class="n">y</span> <span class="o">+</span> <span class="n">sample_weights</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_make_train_function</span><span class="p">()</span>
        <span class="n">outputs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">train_function</span><span class="p">(</span><span class="n">ins</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">outputs</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">outputs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">outputs</span>

    <span class="k">def</span> <span class="nf">test_on_batch</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">sample_weight</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Test the model on a single batch of samples.</span>

<span class="sd">        # Arguments</span>
<span class="sd">            x: Numpy array of test data,</span>
<span class="sd">                or list of Numpy arrays if the model has multiple inputs.</span>
<span class="sd">                If all inputs in the model are named,</span>
<span class="sd">                you can also pass a dictionary</span>
<span class="sd">                mapping input names to Numpy arrays.</span>
<span class="sd">            y: Numpy array of target data,</span>
<span class="sd">                or list of Numpy arrays if the model has multiple outputs.</span>
<span class="sd">                If all outputs in the model are named,</span>
<span class="sd">                you can also pass a dictionary</span>
<span class="sd">                mapping output names to Numpy arrays.</span>
<span class="sd">            sample_weight: Optional array of the same length as x, containing</span>
<span class="sd">                weights to apply to the model&#39;s loss for each sample.</span>
<span class="sd">                In the case of temporal data, you can pass a 2D array</span>
<span class="sd">                with shape (samples, sequence_length),</span>
<span class="sd">                to apply a different weight to every timestep of every sample.</span>
<span class="sd">                In this case you should make sure to specify</span>
<span class="sd">                sample_weight_mode=&quot;temporal&quot; in compile().</span>

<span class="sd">        # Returns</span>
<span class="sd">            Scalar test loss (if the model has a single output and no metrics)</span>
<span class="sd">            or list of scalars (if the model has multiple outputs</span>
<span class="sd">            and/or metrics). The attribute `model.metrics_names` will give you</span>
<span class="sd">            the display labels for the scalar outputs.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">sample_weights</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_standardize_user_data</span><span class="p">(</span>
            <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span>
            <span class="n">sample_weight</span><span class="o">=</span><span class="n">sample_weight</span><span class="p">,</span>
            <span class="n">check_batch_axis</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">uses_learning_phase</span> <span class="ow">and</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">K</span><span class="o">.</span><span class="n">learning_phase</span><span class="p">(),</span> <span class="nb">int</span><span class="p">):</span>
            <span class="n">ins</span> <span class="o">=</span> <span class="n">x</span> <span class="o">+</span> <span class="n">y</span> <span class="o">+</span> <span class="n">sample_weights</span> <span class="o">+</span> <span class="p">[</span><span class="mf">0.</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">ins</span> <span class="o">=</span> <span class="n">x</span> <span class="o">+</span> <span class="n">y</span> <span class="o">+</span> <span class="n">sample_weights</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_make_test_function</span><span class="p">()</span>
        <span class="n">outputs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">test_function</span><span class="p">(</span><span class="n">ins</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">outputs</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">outputs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">outputs</span>

    <span class="k">def</span> <span class="nf">predict_on_batch</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns predictions for a single batch of samples.</span>

<span class="sd">        # Arguments</span>
<span class="sd">            x: Input samples, as a Numpy array.</span>

<span class="sd">        # Returns</span>
<span class="sd">            Numpy array(s) of predictions.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">_standardize_input_data</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_feed_input_names</span><span class="p">,</span>
                                    <span class="bp">self</span><span class="o">.</span><span class="n">_feed_input_shapes</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">uses_learning_phase</span> <span class="ow">and</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">K</span><span class="o">.</span><span class="n">learning_phase</span><span class="p">(),</span> <span class="nb">int</span><span class="p">):</span>
            <span class="n">ins</span> <span class="o">=</span> <span class="n">x</span> <span class="o">+</span> <span class="p">[</span><span class="mf">0.</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">ins</span> <span class="o">=</span> <span class="n">x</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_make_predict_function</span><span class="p">()</span>
        <span class="n">outputs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">predict_function</span><span class="p">(</span><span class="n">ins</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">outputs</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">outputs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">outputs</span>

    <span class="nd">@interfaces</span><span class="o">.</span><span class="n">legacy_generator_methods_support</span>
    <span class="k">def</span> <span class="nf">fit_generator</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">generator</span><span class="p">,</span>
                      <span class="n">steps_per_epoch</span><span class="p">,</span>
                      <span class="n">epochs</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
                      <span class="n">verbose</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
                      <span class="n">callbacks</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                      <span class="n">validation_data</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                      <span class="n">validation_steps</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                      <span class="n">class_weight</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                      <span class="n">max_queue_size</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span>
                      <span class="n">workers</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
                      <span class="n">use_multiprocessing</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                      <span class="n">shuffle</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                      <span class="n">initial_epoch</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Fits the model on data yielded batch-by-batch by a Python generator.</span>

<span class="sd">        The generator is run in parallel to the model, for efficiency.</span>
<span class="sd">        For instance, this allows you to do real-time data augmentation</span>
<span class="sd">        on images on CPU in parallel to training your model on GPU.</span>

<span class="sd">        The use of `keras.utils.Sequence` guarantees the ordering</span>
<span class="sd">        and guarantees the single use of every input per epoch when</span>
<span class="sd">        using `use_multiprocessing=True`.</span>

<span class="sd">        # Arguments</span>
<span class="sd">            generator: A generator or an instance of Sequence (keras.utils.Sequence)</span>
<span class="sd">                    object in order to avoid duplicate data</span>
<span class="sd">                    when using multiprocessing.</span>
<span class="sd">                The output of the generator must be either</span>
<span class="sd">                - a tuple (inputs, targets)</span>
<span class="sd">                - a tuple (inputs, targets, sample_weights).</span>
<span class="sd">                All arrays should contain the same number of samples.</span>
<span class="sd">                The generator is expected to loop over its data</span>
<span class="sd">                indefinitely. An epoch finishes when `steps_per_epoch`</span>
<span class="sd">                batches have been seen by the model.</span>
<span class="sd">            steps_per_epoch: Total number of steps (batches of samples)</span>
<span class="sd">                to yield from `generator` before declaring one epoch</span>
<span class="sd">                finished and starting the next epoch. It should typically</span>
<span class="sd">                be equal to the number of unique samples if your dataset</span>
<span class="sd">                divided by the batch size.</span>
<span class="sd">            epochs: Integer, total number of iterations on the data.</span>
<span class="sd">            verbose: Verbosity mode, 0, 1, or 2.</span>
<span class="sd">            callbacks: List of callbacks to be called during training.</span>
<span class="sd">            validation_data: This can be either</span>
<span class="sd">                - a generator for the validation data</span>
<span class="sd">                - a tuple (inputs, targets)</span>
<span class="sd">                - a tuple (inputs, targets, sample_weights).</span>
<span class="sd">            validation_steps: Only relevant if `validation_data`</span>
<span class="sd">                is a generator. Total number of steps (batches of samples)</span>
<span class="sd">                to yield from `generator` before stopping.</span>
<span class="sd">            class_weight: Dictionary mapping class indices to a weight</span>
<span class="sd">                for the class.</span>
<span class="sd">            max_queue_size: Maximum size for the generator queue</span>
<span class="sd">            workers: Maximum number of processes to spin up</span>
<span class="sd">                when using process based threading</span>
<span class="sd">            use_multiprocessing: If True, use process based threading.</span>
<span class="sd">                Note that because</span>
<span class="sd">                this implementation relies on multiprocessing,</span>
<span class="sd">                you should not pass</span>
<span class="sd">                non picklable arguments to the generator</span>
<span class="sd">                as they can&#39;t be passed</span>
<span class="sd">                easily to children processes.</span>
<span class="sd">            shuffle: Whether to shuffle the data at the beginning of each</span>
<span class="sd">                epoch. Only used with instances of `Sequence` (</span>
<span class="sd">                keras.utils.Sequence).</span>
<span class="sd">            initial_epoch: Epoch at which to start training</span>
<span class="sd">                (useful for resuming a previous training run)</span>

<span class="sd">        # Returns</span>
<span class="sd">            A `History` object.</span>

<span class="sd">        # Example</span>

<span class="sd">        ```python</span>
<span class="sd">            def generate_arrays_from_file(path):</span>
<span class="sd">                while 1:</span>
<span class="sd">                    f = open(path)</span>
<span class="sd">                    for line in f:</span>
<span class="sd">                        # create numpy arrays of input data</span>
<span class="sd">                        # and labels, from each line in the file</span>
<span class="sd">                        x1, x2, y = process_line(line)</span>
<span class="sd">                        yield ({&#39;input_1&#39;: x1, &#39;input_2&#39;: x2}, {&#39;output&#39;: y})</span>
<span class="sd">                    f.close()</span>

<span class="sd">            model.fit_generator(generate_arrays_from_file(&#39;/my_file.txt&#39;),</span>
<span class="sd">                                steps_per_epoch=10000, epochs=10)</span>
<span class="sd">        ```</span>

<span class="sd">        # Raises</span>
<span class="sd">            ValueError: In case the generator yields</span>
<span class="sd">                data in an invalid format.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">wait_time</span> <span class="o">=</span> <span class="mf">0.01</span>  <span class="c1"># in seconds</span>
        <span class="n">epoch</span> <span class="o">=</span> <span class="n">initial_epoch</span>

        <span class="n">do_validation</span> <span class="o">=</span> <span class="nb">bool</span><span class="p">(</span><span class="n">validation_data</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_make_train_function</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">do_validation</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_make_test_function</span><span class="p">()</span>

        <span class="c1"># python 2 has &#39;next&#39;, 3 has &#39;__next__&#39;</span>
        <span class="c1"># avoid any explicit version checks</span>
        <span class="n">val_gen</span> <span class="o">=</span> <span class="p">(</span><span class="nb">hasattr</span><span class="p">(</span><span class="n">validation_data</span><span class="p">,</span> <span class="s1">&#39;next&#39;</span><span class="p">)</span> <span class="ow">or</span>
                   <span class="nb">hasattr</span><span class="p">(</span><span class="n">validation_data</span><span class="p">,</span> <span class="s1">&#39;__next__&#39;</span><span class="p">)</span> <span class="ow">or</span>
                   <span class="nb">isinstance</span><span class="p">(</span><span class="n">validation_data</span><span class="p">,</span> <span class="n">Sequence</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">val_gen</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">validation_steps</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;When using a generator for validation data, &#39;</span>
                             <span class="s1">&#39;you must specify a value for &#39;</span>
                             <span class="s1">&#39;`validation_steps`.&#39;</span><span class="p">)</span>

        <span class="c1"># Prepare display labels.</span>
        <span class="n">out_labels</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_deduped_metrics_names</span><span class="p">()</span>
        <span class="n">callback_metrics</span> <span class="o">=</span> <span class="n">out_labels</span> <span class="o">+</span> <span class="p">[</span><span class="s1">&#39;val_&#39;</span> <span class="o">+</span> <span class="n">n</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">out_labels</span><span class="p">]</span>

        <span class="c1"># prepare callbacks</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">history</span> <span class="o">=</span> <span class="n">cbks</span><span class="o">.</span><span class="n">History</span><span class="p">()</span>
        <span class="n">callbacks</span> <span class="o">=</span> <span class="p">[</span><span class="n">cbks</span><span class="o">.</span><span class="n">BaseLogger</span><span class="p">()]</span> <span class="o">+</span> <span class="p">(</span><span class="n">callbacks</span> <span class="ow">or</span> <span class="p">[])</span> <span class="o">+</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">history</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="n">callbacks</span> <span class="o">+=</span> <span class="p">[</span><span class="n">cbks</span><span class="o">.</span><span class="n">ProgbarLogger</span><span class="p">(</span><span class="n">count_mode</span><span class="o">=</span><span class="s1">&#39;steps&#39;</span><span class="p">)]</span>
        <span class="n">callbacks</span> <span class="o">=</span> <span class="n">cbks</span><span class="o">.</span><span class="n">CallbackList</span><span class="p">(</span><span class="n">callbacks</span><span class="p">)</span>

        <span class="c1"># it&#39;s possible to callback a different model than self:</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;callback_model&#39;</span><span class="p">)</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">callback_model</span><span class="p">:</span>
            <span class="n">callback_model</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">callback_model</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">callback_model</span> <span class="o">=</span> <span class="bp">self</span>
        <span class="n">callbacks</span><span class="o">.</span><span class="n">set_model</span><span class="p">(</span><span class="n">callback_model</span><span class="p">)</span>
        <span class="n">callbacks</span><span class="o">.</span><span class="n">set_params</span><span class="p">({</span>
            <span class="s1">&#39;epochs&#39;</span><span class="p">:</span> <span class="n">epochs</span><span class="p">,</span>
            <span class="s1">&#39;steps&#39;</span><span class="p">:</span> <span class="n">steps_per_epoch</span><span class="p">,</span>
            <span class="s1">&#39;verbose&#39;</span><span class="p">:</span> <span class="n">verbose</span><span class="p">,</span>
            <span class="s1">&#39;do_validation&#39;</span><span class="p">:</span> <span class="n">do_validation</span><span class="p">,</span>
            <span class="s1">&#39;metrics&#39;</span><span class="p">:</span> <span class="n">callback_metrics</span><span class="p">,</span>
        <span class="p">})</span>
        <span class="n">callbacks</span><span class="o">.</span><span class="n">on_train_begin</span><span class="p">()</span>

        <span class="k">if</span> <span class="n">do_validation</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">val_gen</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">validation_data</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
                <span class="n">val_x</span><span class="p">,</span> <span class="n">val_y</span> <span class="o">=</span> <span class="n">validation_data</span>
                <span class="n">val_sample_weight</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">validation_data</span><span class="p">)</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
                <span class="n">val_x</span><span class="p">,</span> <span class="n">val_y</span><span class="p">,</span> <span class="n">val_sample_weight</span> <span class="o">=</span> <span class="n">validation_data</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;`validation_data` should be a tuple &#39;</span>
                                 <span class="s1">&#39;`(val_x, val_y, val_sample_weight)` &#39;</span>
                                 <span class="s1">&#39;or `(val_x, val_y)`. Found: &#39;</span> <span class="o">+</span>
                                 <span class="nb">str</span><span class="p">(</span><span class="n">validation_data</span><span class="p">))</span>
            <span class="n">val_x</span><span class="p">,</span> <span class="n">val_y</span><span class="p">,</span> <span class="n">val_sample_weights</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_standardize_user_data</span><span class="p">(</span>
                <span class="n">val_x</span><span class="p">,</span> <span class="n">val_y</span><span class="p">,</span> <span class="n">val_sample_weight</span><span class="p">)</span>
            <span class="n">val_data</span> <span class="o">=</span> <span class="n">val_x</span> <span class="o">+</span> <span class="n">val_y</span> <span class="o">+</span> <span class="n">val_sample_weights</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">uses_learning_phase</span> <span class="ow">and</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">K</span><span class="o">.</span><span class="n">learning_phase</span><span class="p">(),</span> <span class="nb">int</span><span class="p">):</span>
                <span class="n">val_data</span> <span class="o">+=</span> <span class="p">[</span><span class="mf">0.</span><span class="p">]</span>
            <span class="k">for</span> <span class="n">cbk</span> <span class="ow">in</span> <span class="n">callbacks</span><span class="p">:</span>
                <span class="n">cbk</span><span class="o">.</span><span class="n">validation_data</span> <span class="o">=</span> <span class="n">val_data</span>
        <span class="n">is_sequence</span> <span class="o">=</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">generator</span><span class="p">,</span> <span class="n">Sequence</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">is_sequence</span> <span class="ow">and</span> <span class="n">use_multiprocessing</span> <span class="ow">and</span> <span class="n">workers</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
                <span class="ne">UserWarning</span><span class="p">(</span><span class="s1">&#39;Using a generator with `use_multiprocessing=True`&#39;</span>
                            <span class="s1">&#39; and multiple workers may duplicate your data.&#39;</span>
                            <span class="s1">&#39; Please consider using the`keras.utils.Sequence&#39;</span>
                            <span class="s1">&#39; class.&#39;</span><span class="p">))</span>
        <span class="n">enqueuer</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">is_sequence</span><span class="p">:</span>
                <span class="n">enqueuer</span> <span class="o">=</span> <span class="n">OrderedEnqueuer</span><span class="p">(</span><span class="n">generator</span><span class="p">,</span>
                                           <span class="n">use_multiprocessing</span><span class="o">=</span><span class="n">use_multiprocessing</span><span class="p">,</span>
                                           <span class="n">shuffle</span><span class="o">=</span><span class="n">shuffle</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">enqueuer</span> <span class="o">=</span> <span class="n">GeneratorEnqueuer</span><span class="p">(</span><span class="n">generator</span><span class="p">,</span>
                                             <span class="n">use_multiprocessing</span><span class="o">=</span><span class="n">use_multiprocessing</span><span class="p">,</span>
                                             <span class="n">wait_time</span><span class="o">=</span><span class="n">wait_time</span><span class="p">)</span>
            <span class="n">enqueuer</span><span class="o">.</span><span class="n">start</span><span class="p">(</span><span class="n">workers</span><span class="o">=</span><span class="n">workers</span><span class="p">,</span> <span class="n">max_queue_size</span><span class="o">=</span><span class="n">max_queue_size</span><span class="p">)</span>
            <span class="n">output_generator</span> <span class="o">=</span> <span class="n">enqueuer</span><span class="o">.</span><span class="n">get</span><span class="p">()</span>

            <span class="n">callback_model</span><span class="o">.</span><span class="n">stop_training</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="k">while</span> <span class="n">epoch</span> <span class="o">&lt;</span> <span class="n">epochs</span><span class="p">:</span>
                <span class="n">callbacks</span><span class="o">.</span><span class="n">on_epoch_begin</span><span class="p">(</span><span class="n">epoch</span><span class="p">)</span>
                <span class="n">steps_done</span> <span class="o">=</span> <span class="mi">0</span>
                <span class="n">batch_index</span> <span class="o">=</span> <span class="mi">0</span>
                <span class="k">while</span> <span class="n">steps_done</span> <span class="o">&lt;</span> <span class="n">steps_per_epoch</span><span class="p">:</span>
                    <span class="n">generator_output</span> <span class="o">=</span> <span class="nb">next</span><span class="p">(</span><span class="n">output_generator</span><span class="p">)</span>

                    <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">generator_output</span><span class="p">,</span> <span class="s1">&#39;__len__&#39;</span><span class="p">):</span>
                        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Output of generator should be &#39;</span>
                                         <span class="s1">&#39;a tuple `(x, y, sample_weight)` &#39;</span>
                                         <span class="s1">&#39;or `(x, y)`. Found: &#39;</span> <span class="o">+</span>
                                         <span class="nb">str</span><span class="p">(</span><span class="n">generator_output</span><span class="p">))</span>
                    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">generator_output</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
                        <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="n">generator_output</span>
                        <span class="n">sample_weight</span> <span class="o">=</span> <span class="kc">None</span>
                    <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">generator_output</span><span class="p">)</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
                        <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">sample_weight</span> <span class="o">=</span> <span class="n">generator_output</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Output of generator should be &#39;</span>
                                         <span class="s1">&#39;a tuple `(x, y, sample_weight)` &#39;</span>
                                         <span class="s1">&#39;or `(x, y)`. Found: &#39;</span> <span class="o">+</span>
                                         <span class="nb">str</span><span class="p">(</span><span class="n">generator_output</span><span class="p">))</span>
                    <span class="c1"># build batch logs</span>
                    <span class="n">batch_logs</span> <span class="o">=</span> <span class="p">{}</span>
                    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
                        <span class="n">batch_size</span> <span class="o">=</span> <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
                        <span class="n">batch_size</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">values</span><span class="p">())[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">batch_size</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                    <span class="n">batch_logs</span><span class="p">[</span><span class="s1">&#39;batch&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">batch_index</span>
                    <span class="n">batch_logs</span><span class="p">[</span><span class="s1">&#39;size&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">batch_size</span>
                    <span class="n">callbacks</span><span class="o">.</span><span class="n">on_batch_begin</span><span class="p">(</span><span class="n">batch_index</span><span class="p">,</span> <span class="n">batch_logs</span><span class="p">)</span>

                    <span class="n">outs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">train_on_batch</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span>
                                               <span class="n">sample_weight</span><span class="o">=</span><span class="n">sample_weight</span><span class="p">,</span>
                                               <span class="n">class_weight</span><span class="o">=</span><span class="n">class_weight</span><span class="p">)</span>

                    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">outs</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
                        <span class="n">outs</span> <span class="o">=</span> <span class="p">[</span><span class="n">outs</span><span class="p">]</span>
                    <span class="k">for</span> <span class="n">l</span><span class="p">,</span> <span class="n">o</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">out_labels</span><span class="p">,</span> <span class="n">outs</span><span class="p">):</span>
                        <span class="n">batch_logs</span><span class="p">[</span><span class="n">l</span><span class="p">]</span> <span class="o">=</span> <span class="n">o</span>

                    <span class="n">callbacks</span><span class="o">.</span><span class="n">on_batch_end</span><span class="p">(</span><span class="n">batch_index</span><span class="p">,</span> <span class="n">batch_logs</span><span class="p">)</span>

                    <span class="c1"># Construct epoch logs.</span>
                    <span class="n">epoch_logs</span> <span class="o">=</span> <span class="p">{}</span>
                    <span class="n">batch_index</span> <span class="o">+=</span> <span class="mi">1</span>
                    <span class="n">steps_done</span> <span class="o">+=</span> <span class="mi">1</span>

                    <span class="c1"># Epoch finished.</span>
                    <span class="k">if</span> <span class="n">steps_done</span> <span class="o">&gt;=</span> <span class="n">steps_per_epoch</span> <span class="ow">and</span> <span class="n">do_validation</span><span class="p">:</span>
                        <span class="k">if</span> <span class="n">val_gen</span><span class="p">:</span>
                            <span class="n">val_outs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">evaluate_generator</span><span class="p">(</span>
                                <span class="n">validation_data</span><span class="p">,</span>
                                <span class="n">validation_steps</span><span class="p">,</span>
                                <span class="n">max_queue_size</span><span class="o">=</span><span class="n">max_queue_size</span><span class="p">,</span>
                                <span class="n">workers</span><span class="o">=</span><span class="n">workers</span><span class="p">,</span>
                                <span class="n">use_multiprocessing</span><span class="o">=</span><span class="n">use_multiprocessing</span><span class="p">)</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="c1"># No need for try/except because</span>
                            <span class="c1"># data has already been validated.</span>
                            <span class="n">val_outs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">evaluate</span><span class="p">(</span>
                                <span class="n">val_x</span><span class="p">,</span> <span class="n">val_y</span><span class="p">,</span>
                                <span class="n">batch_size</span><span class="o">=</span><span class="n">batch_size</span><span class="p">,</span>
                                <span class="n">sample_weight</span><span class="o">=</span><span class="n">val_sample_weights</span><span class="p">,</span>
                                <span class="n">verbose</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
                        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">val_outs</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
                            <span class="n">val_outs</span> <span class="o">=</span> <span class="p">[</span><span class="n">val_outs</span><span class="p">]</span>
                        <span class="c1"># Same labels assumed.</span>
                        <span class="k">for</span> <span class="n">l</span><span class="p">,</span> <span class="n">o</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">out_labels</span><span class="p">,</span> <span class="n">val_outs</span><span class="p">):</span>
                            <span class="n">epoch_logs</span><span class="p">[</span><span class="s1">&#39;val_&#39;</span> <span class="o">+</span> <span class="n">l</span><span class="p">]</span> <span class="o">=</span> <span class="n">o</span>

                    <span class="k">if</span> <span class="n">callback_model</span><span class="o">.</span><span class="n">stop_training</span><span class="p">:</span>
                        <span class="k">break</span>

                <span class="n">callbacks</span><span class="o">.</span><span class="n">on_epoch_end</span><span class="p">(</span><span class="n">epoch</span><span class="p">,</span> <span class="n">epoch_logs</span><span class="p">)</span>
                <span class="n">epoch</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="k">if</span> <span class="n">callback_model</span><span class="o">.</span><span class="n">stop_training</span><span class="p">:</span>
                    <span class="k">break</span>

        <span class="k">finally</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">enqueuer</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">enqueuer</span><span class="o">.</span><span class="n">stop</span><span class="p">()</span>

        <span class="n">callbacks</span><span class="o">.</span><span class="n">on_train_end</span><span class="p">()</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">history</span>

    <span class="nd">@interfaces</span><span class="o">.</span><span class="n">legacy_generator_methods_support</span>
    <span class="k">def</span> <span class="nf">evaluate_generator</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">generator</span><span class="p">,</span> <span class="n">steps</span><span class="p">,</span>
                           <span class="n">max_queue_size</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span>
                           <span class="n">workers</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
                           <span class="n">use_multiprocessing</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Evaluates the model on a data generator.</span>

<span class="sd">        The generator should return the same kind of data</span>
<span class="sd">        as accepted by `test_on_batch`.</span>

<span class="sd">        # Arguments</span>
<span class="sd">            generator: Generator yielding tuples (inputs, targets)</span>
<span class="sd">                or (inputs, targets, sample_weights)</span>
<span class="sd">                or an instance of Sequence (keras.utils.Sequence)</span>
<span class="sd">                    object in order to avoid duplicate data</span>
<span class="sd">                    when using multiprocessing.</span>
<span class="sd">            steps: Total number of steps (batches of samples)</span>
<span class="sd">                to yield from `generator` before stopping.</span>
<span class="sd">            max_queue_size: maximum size for the generator queue</span>
<span class="sd">            workers: maximum number of processes to spin up</span>
<span class="sd">                when using process based threading</span>
<span class="sd">            use_multiprocessing: if True, use process based threading.</span>
<span class="sd">                Note that because</span>
<span class="sd">                this implementation relies on multiprocessing,</span>
<span class="sd">                you should not pass</span>
<span class="sd">                non picklable arguments to the generator</span>
<span class="sd">                as they can&#39;t be passed</span>
<span class="sd">                easily to children processes.</span>

<span class="sd">        # Returns</span>
<span class="sd">            Scalar test loss (if the model has a single output and no metrics)</span>
<span class="sd">            or list of scalars (if the model has multiple outputs</span>
<span class="sd">            and/or metrics). The attribute `model.metrics_names` will give you</span>
<span class="sd">            the display labels for the scalar outputs.</span>

<span class="sd">        # Raises</span>
<span class="sd">            ValueError: In case the generator yields</span>
<span class="sd">                data in an invalid format.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_make_test_function</span><span class="p">()</span>

        <span class="n">steps_done</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">wait_time</span> <span class="o">=</span> <span class="mf">0.01</span>
        <span class="n">all_outs</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">batch_sizes</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">is_sequence</span> <span class="o">=</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">generator</span><span class="p">,</span> <span class="n">Sequence</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">is_sequence</span> <span class="ow">and</span> <span class="n">use_multiprocessing</span> <span class="ow">and</span> <span class="n">workers</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
                <span class="ne">UserWarning</span><span class="p">(</span><span class="s1">&#39;Using a generator with `use_multiprocessing=True`&#39;</span>
                            <span class="s1">&#39; and multiple workers may duplicate your data.&#39;</span>
                            <span class="s1">&#39; Please consider using the`keras.utils.Sequence&#39;</span>
                            <span class="s1">&#39; class.&#39;</span><span class="p">))</span>
        <span class="n">enqueuer</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">is_sequence</span><span class="p">:</span>
                <span class="n">enqueuer</span> <span class="o">=</span> <span class="n">OrderedEnqueuer</span><span class="p">(</span><span class="n">generator</span><span class="p">,</span>
                                           <span class="n">use_multiprocessing</span><span class="o">=</span><span class="n">use_multiprocessing</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">enqueuer</span> <span class="o">=</span> <span class="n">GeneratorEnqueuer</span><span class="p">(</span><span class="n">generator</span><span class="p">,</span>
                                             <span class="n">use_multiprocessing</span><span class="o">=</span><span class="n">use_multiprocessing</span><span class="p">,</span>
                                             <span class="n">wait_time</span><span class="o">=</span><span class="n">wait_time</span><span class="p">)</span>
            <span class="n">enqueuer</span><span class="o">.</span><span class="n">start</span><span class="p">(</span><span class="n">workers</span><span class="o">=</span><span class="n">workers</span><span class="p">,</span> <span class="n">max_queue_size</span><span class="o">=</span><span class="n">max_queue_size</span><span class="p">)</span>
            <span class="n">output_generator</span> <span class="o">=</span> <span class="n">enqueuer</span><span class="o">.</span><span class="n">get</span><span class="p">()</span>

            <span class="k">while</span> <span class="n">steps_done</span> <span class="o">&lt;</span> <span class="n">steps</span><span class="p">:</span>
                <span class="n">generator_output</span> <span class="o">=</span> <span class="nb">next</span><span class="p">(</span><span class="n">output_generator</span><span class="p">)</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">generator_output</span><span class="p">,</span> <span class="s1">&#39;__len__&#39;</span><span class="p">):</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Output of generator should be a tuple &#39;</span>
                                     <span class="s1">&#39;(x, y, sample_weight) &#39;</span>
                                     <span class="s1">&#39;or (x, y). Found: &#39;</span> <span class="o">+</span>
                                     <span class="nb">str</span><span class="p">(</span><span class="n">generator_output</span><span class="p">))</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">generator_output</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
                    <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="n">generator_output</span>
                    <span class="n">sample_weight</span> <span class="o">=</span> <span class="kc">None</span>
                <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">generator_output</span><span class="p">)</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
                    <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">sample_weight</span> <span class="o">=</span> <span class="n">generator_output</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Output of generator should be a tuple &#39;</span>
                                     <span class="s1">&#39;(x, y, sample_weight) &#39;</span>
                                     <span class="s1">&#39;or (x, y). Found: &#39;</span> <span class="o">+</span>
                                     <span class="nb">str</span><span class="p">(</span><span class="n">generator_output</span><span class="p">))</span>
                <span class="n">outs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">test_on_batch</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">sample_weight</span><span class="o">=</span><span class="n">sample_weight</span><span class="p">)</span>

                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
                    <span class="n">batch_size</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
                <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
                    <span class="n">batch_size</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">values</span><span class="p">())[</span><span class="mi">0</span><span class="p">])</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">batch_size</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">batch_size</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Received an empty batch. &#39;</span>
                                     <span class="s1">&#39;Batches should at least contain one item.&#39;</span><span class="p">)</span>
                <span class="n">all_outs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">outs</span><span class="p">)</span>

                <span class="n">steps_done</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="n">batch_sizes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">batch_size</span><span class="p">)</span>

        <span class="k">finally</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">enqueuer</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">enqueuer</span><span class="o">.</span><span class="n">stop</span><span class="p">()</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">outs</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">average</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">all_outs</span><span class="p">),</span>
                              <span class="n">weights</span><span class="o">=</span><span class="n">batch_sizes</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">averages</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">outs</span><span class="p">)):</span>
                <span class="n">averages</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">average</span><span class="p">([</span><span class="n">out</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">out</span> <span class="ow">in</span> <span class="n">all_outs</span><span class="p">],</span>
                                           <span class="n">weights</span><span class="o">=</span><span class="n">batch_sizes</span><span class="p">))</span>
            <span class="k">return</span> <span class="n">averages</span>

    <span class="nd">@interfaces</span><span class="o">.</span><span class="n">legacy_generator_methods_support</span>
    <span class="k">def</span> <span class="nf">predict_generator</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">generator</span><span class="p">,</span> <span class="n">steps</span><span class="p">,</span>
                          <span class="n">max_queue_size</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span>
                          <span class="n">workers</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
                          <span class="n">use_multiprocessing</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                          <span class="n">verbose</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Generates predictions for the input samples from a data generator.</span>

<span class="sd">        The generator should return the same kind of data as accepted by</span>
<span class="sd">        `predict_on_batch`.</span>

<span class="sd">        # Arguments</span>
<span class="sd">            generator: Generator yielding batches of input samples</span>
<span class="sd">                    or an instance of Sequence (keras.utils.Sequence)</span>
<span class="sd">                    object in order to avoid duplicate data</span>
<span class="sd">                    when using multiprocessing.</span>
<span class="sd">            steps: Total number of steps (batches of samples)</span>
<span class="sd">                to yield from `generator` before stopping.</span>
<span class="sd">            max_queue_size: Maximum size for the generator queue.</span>
<span class="sd">            workers: Maximum number of processes to spin up</span>
<span class="sd">                when using process based threading</span>
<span class="sd">            use_multiprocessing: If `True`, use process based threading.</span>
<span class="sd">                Note that because</span>
<span class="sd">                this implementation relies on multiprocessing,</span>
<span class="sd">                you should not pass</span>
<span class="sd">                non picklable arguments to the generator</span>
<span class="sd">                as they can&#39;t be passed</span>
<span class="sd">                easily to children processes.</span>
<span class="sd">            verbose: verbosity mode, 0 or 1.</span>

<span class="sd">        # Returns</span>
<span class="sd">            Numpy array(s) of predictions.</span>

<span class="sd">        # Raises</span>
<span class="sd">            ValueError: In case the generator yields</span>
<span class="sd">                data in an invalid format.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_make_predict_function</span><span class="p">()</span>

        <span class="n">steps_done</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">wait_time</span> <span class="o">=</span> <span class="mf">0.01</span>
        <span class="n">all_outs</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">is_sequence</span> <span class="o">=</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">generator</span><span class="p">,</span> <span class="n">Sequence</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">is_sequence</span> <span class="ow">and</span> <span class="n">use_multiprocessing</span> <span class="ow">and</span> <span class="n">workers</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
                <span class="ne">UserWarning</span><span class="p">(</span><span class="s1">&#39;Using a generator with `use_multiprocessing=True`&#39;</span>
                            <span class="s1">&#39; and multiple workers may duplicate your data.&#39;</span>
                            <span class="s1">&#39; Please consider using the`keras.utils.Sequence&#39;</span>
                            <span class="s1">&#39; class.&#39;</span><span class="p">))</span>
        <span class="n">enqueuer</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">is_sequence</span><span class="p">:</span>
                <span class="n">enqueuer</span> <span class="o">=</span> <span class="n">OrderedEnqueuer</span><span class="p">(</span><span class="n">generator</span><span class="p">,</span>
                                           <span class="n">use_multiprocessing</span><span class="o">=</span><span class="n">use_multiprocessing</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">enqueuer</span> <span class="o">=</span> <span class="n">GeneratorEnqueuer</span><span class="p">(</span><span class="n">generator</span><span class="p">,</span>
                                             <span class="n">use_multiprocessing</span><span class="o">=</span><span class="n">use_multiprocessing</span><span class="p">,</span>
                                             <span class="n">wait_time</span><span class="o">=</span><span class="n">wait_time</span><span class="p">)</span>
            <span class="n">enqueuer</span><span class="o">.</span><span class="n">start</span><span class="p">(</span><span class="n">workers</span><span class="o">=</span><span class="n">workers</span><span class="p">,</span> <span class="n">max_queue_size</span><span class="o">=</span><span class="n">max_queue_size</span><span class="p">)</span>
            <span class="n">output_generator</span> <span class="o">=</span> <span class="n">enqueuer</span><span class="o">.</span><span class="n">get</span><span class="p">()</span>

            <span class="k">if</span> <span class="n">verbose</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">progbar</span> <span class="o">=</span> <span class="n">Progbar</span><span class="p">(</span><span class="n">target</span><span class="o">=</span><span class="n">steps</span><span class="p">)</span>

            <span class="k">while</span> <span class="n">steps_done</span> <span class="o">&lt;</span> <span class="n">steps</span><span class="p">:</span>
                <span class="n">generator_output</span> <span class="o">=</span> <span class="nb">next</span><span class="p">(</span><span class="n">output_generator</span><span class="p">)</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">generator_output</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">):</span>
                    <span class="c1"># Compatibility with the generators</span>
                    <span class="c1"># used for training.</span>
                    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">generator_output</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
                        <span class="n">x</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">generator_output</span>
                    <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">generator_output</span><span class="p">)</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
                        <span class="n">x</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">generator_output</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Output of generator should be &#39;</span>
                                         <span class="s1">&#39;a tuple `(x, y, sample_weight)` &#39;</span>
                                         <span class="s1">&#39;or `(x, y)`. Found: &#39;</span> <span class="o">+</span>
                                         <span class="nb">str</span><span class="p">(</span><span class="n">generator_output</span><span class="p">))</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="c1"># Assumes a generator that only</span>
                    <span class="c1"># yields inputs (not targets and sample weights).</span>
                    <span class="n">x</span> <span class="o">=</span> <span class="n">generator_output</span>

                <span class="n">outs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">predict_on_batch</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">outs</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
                    <span class="n">outs</span> <span class="o">=</span> <span class="p">[</span><span class="n">outs</span><span class="p">]</span>

                <span class="k">if</span> <span class="ow">not</span> <span class="n">all_outs</span><span class="p">:</span>
                    <span class="k">for</span> <span class="n">out</span> <span class="ow">in</span> <span class="n">outs</span><span class="p">:</span>
                        <span class="n">all_outs</span><span class="o">.</span><span class="n">append</span><span class="p">([])</span>

                <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">out</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">outs</span><span class="p">):</span>
                    <span class="n">all_outs</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">out</span><span class="p">)</span>
                <span class="n">steps_done</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="k">if</span> <span class="n">verbose</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="n">progbar</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">steps_done</span><span class="p">)</span>

        <span class="k">finally</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">enqueuer</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">enqueuer</span><span class="o">.</span><span class="n">stop</span><span class="p">()</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">all_outs</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">steps_done</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">all_outs</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span><span class="n">all_outs</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="k">if</span> <span class="n">steps_done</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">[</span><span class="n">out</span> <span class="k">for</span> <span class="n">out</span> <span class="ow">in</span> <span class="n">all_outs</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span><span class="n">out</span><span class="p">)</span> <span class="k">for</span> <span class="n">out</span> <span class="ow">in</span> <span class="n">all_outs</span><span class="p">]</span>
</pre></div>

          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <form class="search" action="../../../search.html" method="get">
      <div><input type="text" name="q" /></div>
      <div><input type="submit" value="Go" /></div>
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="nav-item nav-item-0"><a href="../../../index.html">RadIO 0.1.0 documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="../../index.html" >Module code</a> &#187;</li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &#169; Copyright 2017, analysiscenter.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.6.5.
    </div>
  </body>
</html>