<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>lung_cancer.preprocessing.ct_masked_batch &#8212; RadIO 0.1.0 documentation</title>
    
    <link rel="stylesheet" href="../../../_static/classic.css" type="text/css" />
    <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../../../',
        VERSION:     '0.1.0',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true,
        SOURCELINK_SUFFIX: '.txt'
      };
    </script>
    <script type="text/javascript" src="../../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../../_static/doctools.js"></script>
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" /> 
  </head>
  <body role="document">
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="nav-item nav-item-0"><a href="../../../index.html">RadIO 0.1.0 documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="../../index.html" accesskey="U">Module code</a> &#187;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <h1>Source code for lung_cancer.preprocessing.ct_masked_batch</h1><div class="highlight"><pre>
<span></span><span class="c1"># pylint: disable=no-member</span>
<span class="c1"># pylint: disable=too-many-public-methods</span>
<span class="c1"># pylint: disable=too-many-locals</span>
<span class="c1"># pylint: disable=too-many-arguments</span>

<span class="sd">&quot;&quot;&quot; Batch class CTImagesMaskedBatch for storing CT-scans with masks. &quot;&quot;&quot;</span>

<span class="kn">import</span> <span class="nn">logging</span>

<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">pandas</span> <span class="k">as</span> <span class="nn">pd</span>
<span class="kn">from</span> <span class="nn">numba</span> <span class="k">import</span> <span class="n">njit</span>
<span class="kn">from</span> <span class="nn">skimage</span> <span class="k">import</span> <span class="n">measure</span>

<span class="k">try</span><span class="p">:</span>
    <span class="kn">from</span> <span class="nn">tqdm</span> <span class="k">import</span> <span class="n">tqdm_notebook</span>
<span class="k">except</span> <span class="ne">ImportError</span><span class="p">:</span>
    <span class="n">tqdm_notebook</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span>

<span class="kn">from</span> <span class="nn">.ct_batch</span> <span class="k">import</span> <span class="n">CTImagesBatch</span>
<span class="kn">from</span> <span class="nn">.mask</span> <span class="k">import</span> <span class="n">make_mask_numba</span><span class="p">,</span> <span class="n">create_mask_reg</span>
<span class="kn">from</span> <span class="nn">.histo</span> <span class="k">import</span> <span class="n">sample_histo3d</span>
<span class="kn">from</span> <span class="nn">.crop</span> <span class="k">import</span> <span class="n">make_central_crop</span>
<span class="kn">from</span> <span class="nn">..dataset</span> <span class="k">import</span> <span class="n">action</span><span class="p">,</span> <span class="n">any_action_failed</span><span class="p">,</span> <span class="n">DatasetIndex</span><span class="p">,</span> <span class="n">SkipBatchException</span>

<span class="n">LOGGING_FMT</span> <span class="o">=</span> <span class="p">(</span><span class="sa">u</span><span class="s2">&quot;</span><span class="si">%(filename)s</span><span class="s2">[LINE:</span><span class="si">%(lineno)d</span><span class="s2">]#&quot;</span> <span class="o">+</span>
               <span class="s2">&quot;</span><span class="si">%(levelname)-8s</span><span class="s2"> [</span><span class="si">%(asctime)s</span><span class="s2">]  </span><span class="si">%(message)s</span><span class="s2">&quot;</span><span class="p">)</span>
<span class="n">logging</span><span class="o">.</span><span class="n">basicConfig</span><span class="p">(</span><span class="nb">format</span><span class="o">=</span><span class="n">LOGGING_FMT</span><span class="p">,</span> <span class="n">level</span><span class="o">=</span><span class="n">logging</span><span class="o">.</span><span class="n">DEBUG</span><span class="p">)</span>

<span class="n">logger</span> <span class="o">=</span> <span class="n">logging</span><span class="o">.</span><span class="n">getLogger</span><span class="p">(</span><span class="vm">__name__</span><span class="p">)</span>  <span class="c1"># pylint: disable=invalid-name</span>


<span class="nd">@njit</span><span class="p">(</span><span class="n">nogil</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<div class="viewcode-block" id="get_nodules_numba"><a class="viewcode-back" href="../../../temp_rst/lung_cancer.preprocessing.html#lung_cancer.preprocessing.ct_masked_batch.get_nodules_numba">[docs]</a><span class="k">def</span> <span class="nf">get_nodules_numba</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">positions</span><span class="p">,</span> <span class="n">size</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Fetch nodules from array by starting positions.</span>

<span class="sd">    Takes array with data of shape (z, y, x) from `batch`,</span>
<span class="sd">    ndarray(p, 3) with starting indices of nodules where p is number</span>
<span class="sd">    of nodules and size of type ndarray(3, ) which contains</span>
<span class="sd">    sizes of nodules along each axis. The output is 3d ndarray with nodules</span>
<span class="sd">    put in CTImagesBatch-compatible skyscraper structure.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    data :       ndarray</span>
<span class="sd">                 CTImagesBatch `skyscraper` represented by 3D ndarray.</span>
<span class="sd">    positions :  ndarray(l, 3) of int</span>
<span class="sd">                 Contains nodules&#39; starting indices along [zyx]-axis accordingly in `data`.</span>
<span class="sd">    size :       ndarray(3,) of int</span>
<span class="sd">                 Contains nodules&#39; sizes along each axis (z,y,x).</span>
<span class="sd">    Note</span>
<span class="sd">    ----</span>
<span class="sd">    Dtypes of positions and size arrays must be the same.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ndarray</span>
<span class="sd">            3d ndarray with nodules</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">out_arr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">np</span><span class="o">.</span><span class="n">int</span><span class="p">(</span><span class="n">positions</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="n">size</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">size</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">size</span><span class="p">[</span><span class="mi">2</span><span class="p">]))</span>

    <span class="n">n_positions</span> <span class="o">=</span> <span class="n">positions</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_positions</span><span class="p">):</span>
        <span class="n">out_arr</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="n">positions</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="mi">0</span><span class="p">]:</span> <span class="n">positions</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">size</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
                                   <span class="n">positions</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="mi">1</span><span class="p">]:</span> <span class="n">positions</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">size</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span>
                                   <span class="n">positions</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="mi">2</span><span class="p">]:</span> <span class="n">positions</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span> <span class="o">+</span> <span class="n">size</span><span class="p">[</span><span class="mi">2</span><span class="p">]]</span>

    <span class="k">return</span> <span class="n">out_arr</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">n_positions</span> <span class="o">*</span> <span class="n">size</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">size</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">size</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span></div>


<div class="viewcode-block" id="CTImagesMaskedBatch"><a class="viewcode-back" href="../../../temp_rst/lung_cancer.preprocessing.html#lung_cancer.preprocessing.ct_masked_batch.CTImagesMaskedBatch">[docs]</a><span class="k">class</span> <span class="nc">CTImagesMaskedBatch</span><span class="p">(</span><span class="n">CTImagesBatch</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Batch class for storing batch of ct-scans with masks for nodules.</span>

<span class="sd">    Allows to load info about cancer nodules, then create cancer-masks</span>
<span class="sd">        for each patient. Created masks are stored in self.masks</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    index : dataset.index</span>
<span class="sd">            ids of scans to be put in a batch</span>

<span class="sd">    Attributes</span>
<span class="sd">    ----------</span>
<span class="sd">    components :  tuple of strings.</span>
<span class="sd">                  List names of data components of a batch, which are `images`,</span>
<span class="sd">                  `masks`, `origin` and `spacing`.</span>
<span class="sd">                  NOTE: Implementation of this property is required by Base class.</span>
<span class="sd">    num_nodules : int</span>
<span class="sd">                  number of nodules in batch</span>
<span class="sd">    images :      ndarray</span>
<span class="sd">                  contains ct-scans for all patients in batch.</span>
<span class="sd">    masks :       ndarray</span>
<span class="sd">                  contains masks for all patients in batch.</span>
<span class="sd">    nodules :     np.recarray</span>
<span class="sd">                  contains info on cancer nodules location.</span>
<span class="sd">                  record array contains the following information about nodules:</span>
<span class="sd">                   - self.nodules.nodule_center -- ndarray(num_nodules, 3) centers of</span>
<span class="sd">                     nodules in world coords;</span>
<span class="sd">                   - self.nodules.nodule_size -- ndarray(num_nodules, 3) sizes of</span>
<span class="sd">                     nodules along z, y, x in world coord;</span>
<span class="sd">                   - self.nodules.img_size -- ndarray(num_nodules, 3) sizes of images of</span>
<span class="sd">                     patient data corresponding to nodules;</span>
<span class="sd">                   - self.nodules.offset -- ndarray(num_nodules, 3) position of individual</span>
<span class="sd">                     patient scan inside batch;</span>
<span class="sd">                   - self.nodules.spacing -- ndarray(num_nodules, 3) of spacing attribute</span>
<span class="sd">                     of patients which correspond to nodules;</span>
<span class="sd">                   - self.nodules.origin -- ndarray(num_nodules, 3) of origin attribute</span>
<span class="sd">                     of patients which correspond to nodules.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">nodules_dtype</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dtype</span><span class="p">([(</span><span class="s1">&#39;patient_pos&#39;</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">int</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span>
                              <span class="p">(</span><span class="s1">&#39;offset&#39;</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">int</span><span class="p">,</span> <span class="p">(</span><span class="mi">3</span><span class="p">,)),</span>
                              <span class="p">(</span><span class="s1">&#39;img_size&#39;</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">int</span><span class="p">,</span> <span class="p">(</span><span class="mi">3</span><span class="p">,)),</span>
                              <span class="p">(</span><span class="s1">&#39;nodule_center&#39;</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">float</span><span class="p">,</span> <span class="p">(</span><span class="mi">3</span><span class="p">,)),</span>
                              <span class="p">(</span><span class="s1">&#39;nodule_size&#39;</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">float</span><span class="p">,</span> <span class="p">(</span><span class="mi">3</span><span class="p">,)),</span>
                              <span class="p">(</span><span class="s1">&#39;spacing&#39;</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">float</span><span class="p">,</span> <span class="p">(</span><span class="mi">3</span><span class="p">,)),</span>
                              <span class="p">(</span><span class="s1">&#39;origin&#39;</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">float</span><span class="p">,</span> <span class="p">(</span><span class="mi">3</span><span class="p">,))])</span>

    <span class="nd">@staticmethod</span>
<div class="viewcode-block" id="CTImagesMaskedBatch.make_indices"><a class="viewcode-back" href="../../../temp_rst/lung_cancer.preprocessing.html#lung_cancer.preprocessing.ct_masked_batch.CTImagesMaskedBatch.make_indices">[docs]</a>    <span class="k">def</span> <span class="nf">make_indices</span><span class="p">(</span><span class="n">size</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Generate list of batch indices of given `size`.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        size : int</span>
<span class="sd">               size of list with indices</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        list</span>
<span class="sd">            list of random indices</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">CTImagesMaskedBatch</span><span class="o">.</span><span class="n">make_filename</span><span class="p">()</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">size</span><span class="p">)])</span></div>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Execute Batch construction and init of basic attributes</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        index : Dataset.Index class.</span>
<span class="sd">                Required indexing of objects (files).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">index</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">masks</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nodules</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">labels</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">components</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Components&#39; property.</span>

<span class="sd">        See doc of Base batch in dataset for information.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        (str, str, str, str)</span>
<span class="sd">                       names of components returned from __getitem__.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="s1">&#39;images&#39;</span><span class="p">,</span> <span class="s1">&#39;masks&#39;</span><span class="p">,</span> <span class="s1">&#39;spacing&#39;</span><span class="p">,</span> <span class="s1">&#39;origin&#39;</span>

    <span class="nd">@action</span>
<div class="viewcode-block" id="CTImagesMaskedBatch.load"><a class="viewcode-back" href="../../../temp_rst/lung_cancer.preprocessing.html#lung_cancer.preprocessing.ct_masked_batch.CTImagesMaskedBatch.load">[docs]</a>    <span class="k">def</span> <span class="nf">load</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">source</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">fmt</span><span class="o">=</span><span class="s1">&#39;dicom&#39;</span><span class="p">,</span> <span class="n">bounds</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>      <span class="c1"># pylint: disable=arguments-differ</span>
             <span class="n">origin</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">spacing</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">nodules</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">masks</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
             <span class="n">src_blosc</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Load data in batch with scans and masks.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        fmt :       str</span>
<span class="sd">                    type of data. Can be &#39;dicom&#39;|&#39;blosc&#39;|&#39;raw&#39;|&#39;ndarray&#39;</span>
<span class="sd">        source :    ndarray(n_patients * z, y, x) or None</span>
<span class="sd">                    input array with `skyscraper` (stacked scans),</span>
<span class="sd">                    needed iff fmt = &#39;ndarray&#39;.</span>
<span class="sd">        bounds :    ndarray(n_patients, dtype=np.int) or None</span>
<span class="sd">                    bound-floors index for patients.</span>
<span class="sd">                    Needed iff fmt=&#39;ndarray&#39;</span>
<span class="sd">        origin :    ndarray(n_patients, 3) or None</span>
<span class="sd">                    origins of scans in world coordinates.</span>
<span class="sd">                    Needed only if fmt=&#39;ndarray&#39;</span>
<span class="sd">        spacing :   ndarray(n_patients, 3) or None</span>
<span class="sd">                    ndarray with spacings of patients along `z,y,x` axes.</span>
<span class="sd">                    Needed only if fmt=&#39;ndarray&#39;</span>
<span class="sd">        src_blosc : list/tuple/string</span>
<span class="sd">                    Contains names of batch component(s) that should be loaded from blosc file.</span>
<span class="sd">                    Needed only if fmt=&#39;blosc&#39;. If None, all components are loaded.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>

<span class="sd">        &gt;&gt;&gt; index = FilesIndex(path=&quot;/some/path/*.mhd, no_ext=True&quot;)</span>
<span class="sd">        &gt;&gt;&gt; batch = CTImagesMaskedBatch(index)</span>
<span class="sd">        &gt;&gt;&gt; batch.load(fmt=&#39;raw&#39;)</span>

<span class="sd">        &gt;&gt;&gt; batch.load(src=source_array, fmt=&#39;ndarray&#39;, bounds=bounds,</span>
<span class="sd">        ...            origin=origin_dict, spacing=spacing_dict)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">params</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">source</span><span class="o">=</span><span class="n">source</span><span class="p">,</span> <span class="n">bounds</span><span class="o">=</span><span class="n">bounds</span><span class="p">,</span>
                      <span class="n">origin</span><span class="o">=</span><span class="n">origin</span><span class="p">,</span> <span class="n">spacing</span><span class="o">=</span><span class="n">spacing</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">fmt</span> <span class="o">==</span> <span class="s1">&#39;ndarray&#39;</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_init_data</span><span class="p">(</span><span class="o">**</span><span class="n">params</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">nodules</span> <span class="o">=</span> <span class="n">nodules</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">masks</span> <span class="o">=</span> <span class="n">masks</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># TODO check this</span>
            <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">fmt</span><span class="o">=</span><span class="n">fmt</span><span class="p">,</span> <span class="o">**</span><span class="n">params</span><span class="p">,</span> <span class="n">src_blosc</span><span class="o">=</span><span class="n">src_blosc</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span></div>

    <span class="nd">@action</span>
<div class="viewcode-block" id="CTImagesMaskedBatch.dump"><a class="viewcode-back" href="../../../temp_rst/lung_cancer.preprocessing.html#lung_cancer.preprocessing.ct_masked_batch.CTImagesMaskedBatch.dump">[docs]</a>    <span class="k">def</span> <span class="nf">dump</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dst</span><span class="p">,</span> <span class="n">src</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">fmt</span><span class="o">=</span><span class="s1">&#39;blosc&#39;</span><span class="p">):</span>                <span class="c1"># pylint: disable=arguments-differ</span>
        <span class="sd">&quot;&quot;&quot; Dump scans to dst-folder in specified format.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        dst : str</span>
<span class="sd">              destinatio-folder where all patients&#39; data should be put</span>
<span class="sd">        src : str or list/tuple</span>
<span class="sd">              component(s) that we need to dump. If not</span>
<span class="sd">              supplied, dump all components + shapes of scans</span>
<span class="sd">        fmt : &#39;blosc&#39;</span>
<span class="sd">              format of dump. Currently only blosc-format is supported;</span>
<span class="sd">              in this case folder for each patient is created, patient&#39;s data</span>
<span class="sd">              is put into images.blk, masks.blk,</span>
<span class="sd">              attributes are put into files attr_name.cpkl</span>
<span class="sd">              (e.g., spacing.cpkl)</span>

<span class="sd">        See docstring of parent-batch for examples.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># if src is not supplied, dump all components and shapes</span>
        <span class="k">if</span> <span class="n">src</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">src</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">components</span> <span class="o">+</span> <span class="p">(</span><span class="s1">&#39;images_shape&#39;</span><span class="p">,</span> <span class="p">)</span>

        <span class="c1"># convert src to iterable 1d-array</span>
        <span class="n">src</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">src</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>

        <span class="k">if</span> <span class="s1">&#39;masks&#39;</span> <span class="ow">in</span> <span class="n">src</span> <span class="ow">and</span> <span class="s1">&#39;images_shape&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">src</span><span class="p">:</span>
            <span class="n">src</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">src</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="s1">&#39;images_shape&#39;</span><span class="p">,</span> <span class="p">)</span>

        <span class="c1"># execute parent-method</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">dump</span><span class="p">(</span><span class="n">dst</span><span class="o">=</span><span class="n">dst</span><span class="p">,</span> <span class="n">src</span><span class="o">=</span><span class="n">src</span><span class="p">,</span> <span class="n">fmt</span><span class="o">=</span><span class="n">fmt</span><span class="p">)</span>  <span class="c1"># pylint: disable=no-value-for-parameter</span>

        <span class="k">return</span> <span class="bp">self</span></div>

<div class="viewcode-block" id="CTImagesMaskedBatch.nodules_to_df"><a class="viewcode-back" href="../../../temp_rst/lung_cancer.preprocessing.html#lung_cancer.preprocessing.ct_masked_batch.CTImagesMaskedBatch.nodules_to_df">[docs]</a>    <span class="k">def</span> <span class="nf">nodules_to_df</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nodules</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Convert nodules_info ndarray into pandas dataframe.</span>

<span class="sd">        Pandas DataFrame will contain following columns:</span>
<span class="sd">        &#39;source_id&#39; - id of source element of batch;</span>
<span class="sd">        &#39;nodule_id&#39; - generated id for nodules;</span>
<span class="sd">        &#39;locZ&#39;, &#39;locY&#39;, &#39;locX&#39; - coordinates of nodules&#39; centers;</span>
<span class="sd">        &#39;diamZ&#39;, &#39;diamY&#39;, &#39;diamX&#39; - sizes of nodules along zyx axes;</span>

<span class="sd">        Args:</span>
<span class="sd">        - nodules: ndarray of type nodules_info(this type is defined</span>
<span class="sd">        inside of CTImagesMaskedBatch class);</span>

<span class="sd">        Returns:</span>
<span class="sd">        - pd.DataFrame with centers, ids and sizes of nodules;</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">columns</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;nodule_id&#39;</span><span class="p">,</span> <span class="s1">&#39;source_id&#39;</span><span class="p">,</span> <span class="s1">&#39;locZ&#39;</span><span class="p">,</span> <span class="s1">&#39;locY&#39;</span><span class="p">,</span>
                   <span class="s1">&#39;locX&#39;</span><span class="p">,</span> <span class="s1">&#39;diamZ&#39;</span><span class="p">,</span> <span class="s1">&#39;diamY&#39;</span><span class="p">,</span> <span class="s1">&#39;diamX&#39;</span><span class="p">]</span>

        <span class="n">nodule_id</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">make_indices</span><span class="p">(</span><span class="n">nodules</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="k">return</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">({</span><span class="s1">&#39;source_id&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">indices</span><span class="p">[</span><span class="n">nodules</span><span class="o">.</span><span class="n">patient_pos</span><span class="p">],</span>
                             <span class="s1">&#39;nodule_id&#39;</span><span class="p">:</span> <span class="n">nodule_id</span><span class="p">,</span>
                             <span class="s1">&#39;locZ&#39;</span><span class="p">:</span> <span class="n">nodules</span><span class="o">.</span><span class="n">nodule_center</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">],</span>
                             <span class="s1">&#39;locY&#39;</span><span class="p">:</span> <span class="n">nodules</span><span class="o">.</span><span class="n">nodule_center</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">],</span>
                             <span class="s1">&#39;locX&#39;</span><span class="p">:</span> <span class="n">nodules</span><span class="o">.</span><span class="n">nodule_center</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">],</span>
                             <span class="s1">&#39;diamZ&#39;</span><span class="p">:</span> <span class="n">nodules</span><span class="o">.</span><span class="n">nodule_size</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">],</span>
                             <span class="s1">&#39;diamY&#39;</span><span class="p">:</span> <span class="n">nodules</span><span class="o">.</span><span class="n">nodule_size</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">],</span>
                             <span class="s1">&#39;diamX&#39;</span><span class="p">:</span> <span class="n">nodules</span><span class="o">.</span><span class="n">nodule_size</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">]},</span> <span class="n">columns</span><span class="o">=</span><span class="n">columns</span><span class="p">)</span></div>

<div class="viewcode-block" id="CTImagesMaskedBatch.get_pos"><a class="viewcode-back" href="../../../temp_rst/lung_cancer.preprocessing.html#lung_cancer.preprocessing.ct_masked_batch.CTImagesMaskedBatch.get_pos">[docs]</a>    <span class="k">def</span> <span class="nf">get_pos</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">component</span><span class="p">,</span> <span class="n">index</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Return a positon of an item for a given index in data</span>
<span class="sd">        or in self.`component`.</span>

<span class="sd">        Fetch correct position inside batch for an item, looks for it</span>
<span class="sd">        in `data`, if provided, or in `component` in self.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        data :      None or ndarray</span>
<span class="sd">                    data from which subsetting is done.</span>
<span class="sd">                    If None, retrieve position from `component` of batch,</span>
<span class="sd">                    if ndarray, returns index.</span>
<span class="sd">        component : str</span>
<span class="sd">                    name of a component, f.ex. &#39;images&#39;.</span>
<span class="sd">                    if component provided, data should be None.</span>
<span class="sd">        index :     str or int</span>
<span class="sd">                    index of an item to be looked for.</span>
<span class="sd">                    may be key from dataset (str)</span>
<span class="sd">                    or index inside batch (int).</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        int</span>
<span class="sd">            Position of item</span>

<span class="sd">        Note</span>
<span class="sd">        ----</span>
<span class="sd">        This is an overload of get_pos from base Batch-class,</span>
<span class="sd">        see corresponding docstring for detailed explanation.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">data</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">ind_pos</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_verified_pos</span><span class="p">(</span><span class="n">index</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">component</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;images&#39;</span><span class="p">,</span> <span class="s1">&#39;masks&#39;</span><span class="p">]:</span>
                <span class="k">return</span> <span class="nb">slice</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">lower_bounds</span><span class="p">[</span><span class="n">ind_pos</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">upper_bounds</span><span class="p">[</span><span class="n">ind_pos</span><span class="p">])</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="nb">slice</span><span class="p">(</span><span class="n">ind_pos</span><span class="p">,</span> <span class="n">ind_pos</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">index</span></div>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">num_nodules</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Get number of nodules in CTImagesMaskedBatch.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        int</span>
<span class="sd">            number of nodules in CTImagesMaskedBatch.</span>
<span class="sd">            if fetch_nodules_info method has not been called yet returns 0.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">nodules</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">nodules</span><span class="o">.</span><span class="n">patient_pos</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="mi">0</span>

    <span class="nd">@action</span>
<div class="viewcode-block" id="CTImagesMaskedBatch.fetch_nodules_info"><a class="viewcode-back" href="../../../temp_rst/lung_cancer.preprocessing.html#lung_cancer.preprocessing.ct_masked_batch.CTImagesMaskedBatch.fetch_nodules_info">[docs]</a>    <span class="k">def</span> <span class="nf">fetch_nodules_info</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nodules_df</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">nodules_records</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">update</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">images_loaded</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Extract nodules&#39; info from nodules_df into attribute self.nodules.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        nodules_df :      pd.DataFrame</span>
<span class="sd">                          contains:</span>
<span class="sd">                           - &#39;seriesuid&#39;: index of patient or series.</span>
<span class="sd">                           - &#39;z&#39;,&#39;y&#39;,&#39;x&#39;: coordinates of nodules center.</span>
<span class="sd">                           - &#39;diameter&#39;: diameter, in mm.</span>
<span class="sd">        nodules_records : np.recarray</span>
<span class="sd">                          if not None, should</span>
<span class="sd">                          contain the same fields as describe in Note.</span>
<span class="sd">        update :          bool</span>
<span class="sd">                          if False, warning appears to remind that nodules info</span>
<span class="sd">                          will be earased and recomputed.</span>
<span class="sd">        images_loaded :   bool</span>
<span class="sd">                          if True, i.e. `images` component is loaded,</span>
<span class="sd">                          and image_size is used to compute</span>
<span class="sd">                          correct nodules location inside `skyscraper`.</span>
<span class="sd">                          If False, it doesn&#39;t update info of location</span>
<span class="sd">                          inside `skyscraper`.</span>


<span class="sd">        Note</span>
<span class="sd">        ----</span>
<span class="sd">        The method fills in record array self.nodules that contains the following information about nodules:</span>
<span class="sd">                               - self.nodules.nodule_center -- ndarray(num_nodules, 3) centers of</span>
<span class="sd">                                 nodules in world coords;</span>
<span class="sd">                               - self.nodules.nodule_size -- ndarray(num_nodules, 3) sizes of</span>
<span class="sd">                                 nodules along z, y, x in world coord;</span>
<span class="sd">                               - self.nodules.img_size -- ndarray(num_nodules, 3) sizes of images of</span>
<span class="sd">                                 patient data corresponding to nodules;</span>
<span class="sd">                               - self.nodules.offset -- ndarray(num_nodules, 3) of biases of</span>
<span class="sd">                                 patients which correspond to nodules;</span>
<span class="sd">                               - self.nodules.spacing -- ndarray(num_nodules, 3) of spacinf attribute</span>
<span class="sd">                                 of patients which correspond to nodules;</span>
<span class="sd">                               - self.nodules.origin -- ndarray(num_nodules, 3) of origin attribute</span>
<span class="sd">                                 of patients which correspond to nodules.</span>
<span class="sd">                               - self.nodules.patient_pos -- ndarray(num_nodules, 1) refers to</span>
<span class="sd">                                 positions of patients which correspond to stored nodules.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">nodules</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">update</span><span class="p">:</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s2">&quot;Nodules have already been extracted. &quot;</span> <span class="o">+</span>
                           <span class="s2">&quot;Put update argument as True for refreshing&quot;</span><span class="p">)</span>
            <span class="k">return</span> <span class="bp">self</span>

        <span class="k">if</span> <span class="n">nodules_records</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># load from record-array</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">nodules</span> <span class="o">=</span> <span class="n">nodules_records</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># assume that nodules_df is supplied and load from it</span>
            <span class="n">nodules_df</span> <span class="o">=</span> <span class="n">nodules_df</span><span class="o">.</span><span class="n">set_index</span><span class="p">(</span><span class="s1">&#39;seriesuid&#39;</span><span class="p">)</span>

            <span class="n">unique_indices</span> <span class="o">=</span> <span class="n">nodules_df</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">unique</span><span class="p">()</span>
            <span class="n">inter_index</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">intersect1d</span><span class="p">(</span><span class="n">unique_indices</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">indices</span><span class="p">)</span>
            <span class="n">nodules_df</span> <span class="o">=</span> <span class="n">nodules_df</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">inter_index</span><span class="p">,</span>
                                        <span class="p">[</span><span class="s2">&quot;coordZ&quot;</span><span class="p">,</span> <span class="s2">&quot;coordY&quot;</span><span class="p">,</span>
                                         <span class="s2">&quot;coordX&quot;</span><span class="p">,</span> <span class="s2">&quot;diameter_mm&quot;</span><span class="p">]]</span>

            <span class="n">num_nodules</span> <span class="o">=</span> <span class="n">nodules_df</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">nodules</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">rec</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">num_nodules</span><span class="p">,</span>
                                                 <span class="n">dtype</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">nodules_dtype</span><span class="p">))</span>
            <span class="n">counter</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">for</span> <span class="n">pat_id</span><span class="p">,</span> <span class="n">coordz</span><span class="p">,</span> <span class="n">coordy</span><span class="p">,</span> <span class="n">coordx</span><span class="p">,</span> <span class="n">diam</span> <span class="ow">in</span> <span class="n">nodules_df</span><span class="o">.</span><span class="n">itertuples</span><span class="p">():</span>
                <span class="n">pat_pos</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">get_pos</span><span class="p">(</span><span class="n">pat_id</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">nodules</span><span class="o">.</span><span class="n">patient_pos</span><span class="p">[</span><span class="n">counter</span><span class="p">]</span> <span class="o">=</span> <span class="n">pat_pos</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">nodules</span><span class="o">.</span><span class="n">nodule_center</span><span class="p">[</span><span class="n">counter</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">coordz</span><span class="p">,</span>
                                                                   <span class="n">coordy</span><span class="p">,</span>
                                                                   <span class="n">coordx</span><span class="p">])</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">nodules</span><span class="o">.</span><span class="n">nodule_size</span><span class="p">[</span><span class="n">counter</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">diam</span><span class="p">,</span> <span class="n">diam</span><span class="p">,</span> <span class="n">diam</span><span class="p">])</span>
                <span class="n">counter</span> <span class="o">+=</span> <span class="mi">1</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_refresh_nodules_info</span><span class="p">(</span><span class="n">images_loaded</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span></div>

    <span class="nd">@action</span>
<div class="viewcode-block" id="CTImagesMaskedBatch.fetch_nodules_from_mask"><a class="viewcode-back" href="../../../temp_rst/lung_cancer.preprocessing.html#lung_cancer.preprocessing.ct_masked_batch.CTImagesMaskedBatch.fetch_nodules_from_mask">[docs]</a>    <span class="k">def</span> <span class="nf">fetch_nodules_from_mask</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">images_loaded</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Fetch nodules info (centers and sizes) from masks.</span>

<span class="sd">        Runs skimage.measure.labels for fetching nodules regions</span>
<span class="sd">        from masks. Extracts nodules info from segmented regions</span>
<span class="sd">        and put this information in self.nodules np.recarray.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        images_loaded : bool</span>
<span class="sd">                        if True, i.e. `images` component is loaded,</span>
<span class="sd">                        and image_size is used to compute</span>
<span class="sd">                        correct nodules location inside `skyscraper`.</span>
<span class="sd">                        If False, it doesn&#39;t update info of location</span>
<span class="sd">                        inside `skyscraper`.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">nodules_list</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">pos</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">)):</span>
            <span class="n">mask</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">pos</span><span class="p">,</span> <span class="s1">&#39;masks&#39;</span><span class="p">)</span>
            <span class="n">mask_labels</span> <span class="o">=</span> <span class="n">measure</span><span class="o">.</span><span class="n">label</span><span class="p">(</span><span class="n">mask</span><span class="p">,</span> <span class="n">background</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">props</span> <span class="ow">in</span> <span class="n">measure</span><span class="o">.</span><span class="n">regionprops</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">int16</span><span class="p">(</span><span class="n">mask_labels</span><span class="p">)):</span>
                <span class="n">center</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">((</span><span class="n">props</span><span class="o">.</span><span class="n">centroid</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
                                     <span class="n">props</span><span class="o">.</span><span class="n">centroid</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span>
                                     <span class="n">props</span><span class="o">.</span><span class="n">centroid</span><span class="p">[</span><span class="mi">2</span><span class="p">]),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float</span><span class="p">)</span>
                <span class="n">center</span> <span class="o">=</span> <span class="n">center</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">spacing</span><span class="p">[</span><span class="n">pos</span><span class="p">]</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">origin</span><span class="p">[</span><span class="n">pos</span><span class="p">]</span>

                <span class="n">diameter</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span>
                    <span class="p">[</span><span class="n">props</span><span class="o">.</span><span class="n">equivalent_diameter</span> <span class="o">/</span> <span class="mi">2</span><span class="p">]</span> <span class="o">*</span> <span class="mi">3</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float</span><span class="p">)</span>
                <span class="n">diameter</span> <span class="o">=</span> <span class="n">diameter</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">spacing</span><span class="p">[</span><span class="n">pos</span><span class="p">]</span>
                <span class="n">nodules_list</span><span class="o">.</span><span class="n">append</span><span class="p">({</span><span class="s1">&#39;patient_pos&#39;</span><span class="p">:</span> <span class="n">pos</span><span class="p">,</span>
                                     <span class="s1">&#39;nodule_center&#39;</span><span class="p">:</span> <span class="n">center</span><span class="p">,</span>
                                     <span class="s1">&#39;nodule_size&#39;</span><span class="p">:</span> <span class="n">diameter</span><span class="p">})</span>

        <span class="n">num_nodules</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">nodules_list</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nodules</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">rec</span><span class="o">.</span><span class="n">array</span><span class="p">(</span>
            <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">num_nodules</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">nodules_dtype</span><span class="p">))</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">nodule</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">nodules_list</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">nodules</span><span class="o">.</span><span class="n">patient_pos</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">nodule</span><span class="p">[</span><span class="s1">&#39;patient_pos&#39;</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">nodules</span><span class="o">.</span><span class="n">nodule_center</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">nodule</span><span class="p">[</span><span class="s1">&#39;nodule_center&#39;</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">nodules</span><span class="o">.</span><span class="n">nodule_size</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">nodule</span><span class="p">[</span><span class="s1">&#39;nodule_size&#39;</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_refresh_nodules_info</span><span class="p">(</span><span class="n">images_loaded</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span></div>

    <span class="c1"># TODO: another name of method</span>
    <span class="k">def</span> <span class="nf">_fit_into_bounds</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="n">variance</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Fetch start voxel coordinates of all nodules.</span>

<span class="sd">        Get start voxel coordinates of all nodules in batch.</span>
<span class="sd">        Note that all nodules are considered to have</span>
<span class="sd">        fixed same size defined by argument size: if nodule is out of</span>
<span class="sd">        patient&#39;s 3d image bounds than it&#39;s center is shifted to border.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        size :     list or tuple of ndarrays</span>
<span class="sd">                   ndarray(3, ) with diameters of nodules in (z,y,x);</span>
<span class="sd">        variance : ndarray(3, )</span>
<span class="sd">                   diagonal elements of multivariate normal distribution,</span>
<span class="sd">                   for sampling random shifts along (z,y,x) correspondingly.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        ndarray</span>
<span class="sd">                start coordinates (z,y,x) of all nodules in batch.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">size</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">size</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int</span><span class="p">)</span>

        <span class="n">center_pix</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nodules</span><span class="o">.</span><span class="n">nodule_center</span> <span class="o">-</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">nodules</span><span class="o">.</span><span class="n">origin</span><span class="p">)</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">nodules</span><span class="o">.</span><span class="n">spacing</span>
        <span class="n">start_pix</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">rint</span><span class="p">(</span><span class="n">center_pix</span><span class="p">)</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">rint</span><span class="p">(</span><span class="n">size</span> <span class="o">/</span> <span class="mi">2</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">variance</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">start_pix</span> <span class="o">+=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">multivariate_normal</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="mi">3</span><span class="p">),</span>
                                                       <span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="n">variance</span><span class="p">),</span>
                                                       <span class="bp">self</span><span class="o">.</span><span class="n">nodules</span><span class="o">.</span><span class="n">patient_pos</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="n">end_pix</span> <span class="o">=</span> <span class="n">start_pix</span> <span class="o">+</span> <span class="n">size</span>

        <span class="n">bias_upper</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span><span class="n">end_pix</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">nodules</span><span class="o">.</span><span class="n">img_size</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
        <span class="n">start_pix</span> <span class="o">-=</span> <span class="n">bias_upper</span>
        <span class="n">end_pix</span> <span class="o">-=</span> <span class="n">bias_upper</span>

        <span class="n">bias_lower</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span><span class="o">-</span><span class="n">start_pix</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
        <span class="n">start_pix</span> <span class="o">+=</span> <span class="n">bias_lower</span>
        <span class="n">end_pix</span> <span class="o">+=</span> <span class="n">bias_lower</span>

        <span class="k">return</span> <span class="p">(</span><span class="n">start_pix</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">nodules</span><span class="o">.</span><span class="n">offset</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">int</span><span class="p">)</span>

    <span class="nd">@action</span>
<div class="viewcode-block" id="CTImagesMaskedBatch.create_mask"><a class="viewcode-back" href="../../../temp_rst/lung_cancer.preprocessing.html#lung_cancer.preprocessing.ct_masked_batch.CTImagesMaskedBatch.create_mask">[docs]</a>    <span class="k">def</span> <span class="nf">create_mask</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Create `masks` component from `nodules` component.</span>

<span class="sd">        Note</span>
<span class="sd">        ----</span>
<span class="sd">        `nodules` must be not None before calling this method.</span>
<span class="sd">        see fetch_nodules_info() for more details.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">nodules</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s2">&quot;Info about nodules location must &quot;</span> <span class="o">+</span>
                           <span class="s2">&quot;be loaded before calling this method. &quot;</span> <span class="o">+</span>
                           <span class="s2">&quot;Nothing happened.&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">masks</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">images</span><span class="p">)</span>

        <span class="n">center_pix</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nodules</span><span class="o">.</span><span class="n">nodule_center</span> <span class="o">-</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">nodules</span><span class="o">.</span><span class="n">origin</span><span class="p">)</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">nodules</span><span class="o">.</span><span class="n">spacing</span>
        <span class="n">start_pix</span> <span class="o">=</span> <span class="p">(</span><span class="n">center_pix</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">rint</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nodules</span><span class="o">.</span><span class="n">nodule_size</span> <span class="o">/</span>
                                          <span class="bp">self</span><span class="o">.</span><span class="n">nodules</span><span class="o">.</span><span class="n">spacing</span> <span class="o">/</span> <span class="mi">2</span><span class="p">))</span>
        <span class="n">start_pix</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">rint</span><span class="p">(</span><span class="n">start_pix</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">int</span><span class="p">)</span>
        <span class="n">make_mask_numba</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">masks</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">nodules</span><span class="o">.</span><span class="n">offset</span><span class="p">,</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">nodules</span><span class="o">.</span><span class="n">img_size</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">nodules</span><span class="o">.</span><span class="n">offset</span><span class="p">,</span> <span class="n">start_pix</span><span class="p">,</span>
                        <span class="n">np</span><span class="o">.</span><span class="n">rint</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nodules</span><span class="o">.</span><span class="n">nodule_size</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">nodules</span><span class="o">.</span><span class="n">spacing</span><span class="p">))</span>

        <span class="k">return</span> <span class="bp">self</span></div>

<div class="viewcode-block" id="CTImagesMaskedBatch.fetch_mask"><a class="viewcode-back" href="../../../temp_rst/lung_cancer.preprocessing.html#lung_cancer.preprocessing.ct_masked_batch.CTImagesMaskedBatch.fetch_mask">[docs]</a>    <span class="k">def</span> <span class="nf">fetch_mask</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">shape</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Create `masks` component of different size then `images`,</span>
<span class="sd">        using `nodules` component.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        shape : tuple, list or ndarray of int.</span>
<span class="sd">                (z_dim,y_dim,x_dim), shape of mask to be created.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        ndarray</span>
<span class="sd">               3d array with masks in form of `skyscraper`</span>

<span class="sd">        # TODO: one part of code from here repeats create_mask function</span>
<span class="sd">            better to unify these two func</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">nodules</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s2">&quot;Info about nodules location must &quot;</span> <span class="o">+</span>
                           <span class="s2">&quot;be loaded before calling this method. &quot;</span> <span class="o">+</span>
                           <span class="s2">&quot;Nothing happened.&quot;</span><span class="p">)</span>
        <span class="n">mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">*</span> <span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="p">)</span> <span class="o">+</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">:]))</span>

        <span class="c1"># infer scale factor; assume patients are already resized to equal</span>
        <span class="c1"># shapes</span>
        <span class="n">scale_factor</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">shape</span><span class="p">)</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">images_shape</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:]</span>

        <span class="c1"># get rescaled nodule-centers, nodule-sizes, offsets, locs of nod</span>
        <span class="c1"># starts</span>
        <span class="n">center_scaled</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nodules</span><span class="o">.</span><span class="n">nodule_center</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">nodules</span><span class="o">.</span><span class="n">origin</span><span class="p">)</span> <span class="o">/</span>
                         <span class="bp">self</span><span class="o">.</span><span class="n">nodules</span><span class="o">.</span><span class="n">spacing</span> <span class="o">*</span> <span class="n">scale_factor</span><span class="p">)</span>
        <span class="n">start_scaled</span> <span class="o">=</span> <span class="p">(</span><span class="n">center_scaled</span> <span class="o">-</span> <span class="n">scale_factor</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">nodules</span><span class="o">.</span><span class="n">nodule_size</span> <span class="o">/</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">nodules</span><span class="o">.</span><span class="n">spacing</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span>
        <span class="n">start_scaled</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">rint</span><span class="p">(</span><span class="n">start_scaled</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">int</span><span class="p">)</span>
        <span class="n">offset_scaled</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">rint</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nodules</span><span class="o">.</span><span class="n">offset</span> <span class="o">*</span>
                                <span class="n">scale_factor</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">int</span><span class="p">)</span>
        <span class="n">img_size_scaled</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">rint</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">nodules</span><span class="o">.</span><span class="n">img_size</span> <span class="o">*</span> <span class="n">scale_factor</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">int</span><span class="p">)</span>
        <span class="n">nod_size_scaled</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">rint</span><span class="p">(</span><span class="n">scale_factor</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">nodules</span><span class="o">.</span><span class="n">nodule_size</span> <span class="o">/</span>
                                   <span class="bp">self</span><span class="o">.</span><span class="n">nodules</span><span class="o">.</span><span class="n">spacing</span><span class="p">))</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">int</span><span class="p">)</span>
        <span class="c1"># put nodules into mask</span>
        <span class="n">make_mask_numba</span><span class="p">(</span><span class="n">mask</span><span class="p">,</span> <span class="n">offset_scaled</span><span class="p">,</span> <span class="n">img_size_scaled</span> <span class="o">+</span> <span class="n">offset_scaled</span><span class="p">,</span>
                        <span class="n">start_scaled</span><span class="p">,</span> <span class="n">nod_size_scaled</span><span class="p">)</span>
        <span class="c1"># return ndarray-mask</span>
        <span class="k">return</span> <span class="n">mask</span></div>

    <span class="c1"># TODO rename function to sample_random_nodules_positions</span>
<div class="viewcode-block" id="CTImagesMaskedBatch.sample_random_nodules"><a class="viewcode-back" href="../../../temp_rst/lung_cancer.preprocessing.html#lung_cancer.preprocessing.ct_masked_batch.CTImagesMaskedBatch.sample_random_nodules">[docs]</a>    <span class="k">def</span> <span class="nf">sample_random_nodules</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">num_nodules</span><span class="p">,</span> <span class="n">nodule_size</span><span class="p">,</span> <span class="n">histo</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Sample random nodules positions in CTImagesBatchMasked.</span>

<span class="sd">        Samples random nodules positions in ndarray. Each nodule have shape</span>
<span class="sd">        defined by `nodule_size`. If size of patients&#39; data along z-axis</span>
<span class="sd">        is not the same for different patients, NotImplementedError will be raised.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        num_nodules : int</span>
<span class="sd">                      number of nodules to sample from dataset.</span>
<span class="sd">        nodule_size : ndarray(3, )</span>
<span class="sd">                      crop shape along (z,y,x).</span>
<span class="sd">        histo :       tuple</span>
<span class="sd">                      np.histogram()&#39;s output.</span>
<span class="sd">                      3d-histogram, represented by tuple (bins, edges)</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        ndarray</span>
<span class="sd">                ndarray(num_nodules, 3). 1st array&#39;s dim is an index of sampled</span>
<span class="sd">                nodules, 2nd points out start positions (integers) of nodules</span>
<span class="sd">                in batch `skyscraper`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">all_indices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">))</span>
        <span class="n">sampled_indices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">choice</span><span class="p">(</span>
            <span class="n">all_indices</span><span class="p">,</span> <span class="n">num_nodules</span><span class="p">,</span> <span class="n">replace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="n">offset</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">num_nodules</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span>
        <span class="n">offset</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">lower_bounds</span><span class="p">[</span><span class="n">sampled_indices</span><span class="p">]</span>
        <span class="n">data_shape</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">images_shape</span><span class="p">[</span><span class="n">sampled_indices</span><span class="p">,</span> <span class="p">:]</span>

        <span class="c1"># if supplied, use histogram as the sampler</span>
        <span class="k">if</span> <span class="n">histo</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">sampler</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">size</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">rand</span><span class="p">(</span><span class="n">size</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">sampler</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">size</span><span class="p">:</span> <span class="n">sample_histo3d</span><span class="p">(</span><span class="n">histo</span><span class="p">,</span> <span class="n">size</span><span class="p">)</span>

        <span class="n">samples</span> <span class="o">=</span> <span class="n">sampler</span><span class="p">(</span><span class="n">size</span><span class="o">=</span><span class="n">num_nodules</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">data_shape</span> <span class="o">-</span> <span class="n">nodule_size</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">histo</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">samples</span> <span class="o">/=</span> <span class="n">data_shape</span>

        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">samples</span> <span class="o">+</span> <span class="n">offset</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int</span><span class="p">),</span> <span class="n">sampled_indices</span></div>

    <span class="nd">@action</span>
<div class="viewcode-block" id="CTImagesMaskedBatch.sample_nodules"><a class="viewcode-back" href="../../../temp_rst/lung_cancer.preprocessing.html#lung_cancer.preprocessing.ct_masked_batch.CTImagesMaskedBatch.sample_nodules">[docs]</a>    <span class="k">def</span> <span class="nf">sample_nodules</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">batch_size</span><span class="p">,</span> <span class="n">nodule_size</span><span class="o">=</span><span class="p">(</span><span class="mi">32</span><span class="p">,</span> <span class="mi">64</span><span class="p">,</span> <span class="mi">64</span><span class="p">),</span> <span class="n">share</span><span class="o">=</span><span class="mf">0.8</span><span class="p">,</span> <span class="n">variance</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>        <span class="c1"># pylint: disable=too-many-locals, too-many-statements</span>
                       <span class="n">mask_shape</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">histo</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Sample random crops of `images` and `masks` from batch.</span>


<span class="sd">        Create random crops, both with and without nodules in it, from input batch.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        batch_size :    int</span>
<span class="sd">                        number of nodules in the output batch. Required,</span>
<span class="sd">                        if share=0.0. If None, resulting batch will include all</span>
<span class="sd">                        cancerous nodules</span>
<span class="sd">        nodule_size :   tuple, list or ndarray of int</span>
<span class="sd">                        crop shape along (z,y,x).</span>
<span class="sd">        share :         float</span>
<span class="sd">                        share of cancer crops in the batch.</span>
<span class="sd">                        if input CTImagesBatch contains less cancer</span>
<span class="sd">                        nodules than needed random nodules will be taken;</span>
<span class="sd">        variance :      tuple, list of float</span>
<span class="sd">                        variances of normally distributed random shifts of</span>
<span class="sd">                        nodules&#39; start positions</span>
<span class="sd">        mask_shape :    tuple, list or ndarray</span>
<span class="sd">                        size of `masks` crop in (z, y, x)-order. If not None,</span>
<span class="sd">                        crops with masks would be of mask_shape.</span>
<span class="sd">                        If None, mask crop shape would be equal to crop_size.</span>
<span class="sd">        histo :         tuple</span>
<span class="sd">                        np.histogram()&#39;s output.</span>
<span class="sd">                        Used for sampling non-cancerous crops</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Batch</span>
<span class="sd">                batch with cancerous and non-cancerous crops in a proportion defined by</span>
<span class="sd">                `share` with total `batch_size` nodules. If `share` == 1.0, `batch_size`</span>
<span class="sd">                is None, resulting batch consists of all cancerous crops stored in batch.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># make sure that nodules&#39; info is fetched and args are OK</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">nodules</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">AttributeError</span><span class="p">(</span><span class="s2">&quot;Info about nodules location must &quot;</span> <span class="o">+</span>
                                 <span class="s2">&quot;be loaded before calling this method&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">variance</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">variance</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">variance</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int</span><span class="p">)</span>
            <span class="n">variance</span> <span class="o">=</span> <span class="n">variance</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">variance</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">3</span><span class="p">:</span>
                <span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s1">&#39;Argument variance be np.array-like&#39;</span> <span class="o">+</span>
                               <span class="s1">&#39;and has shape (3,). &#39;</span> <span class="o">+</span>
                               <span class="s1">&#39;Would be used no-scale-shift.&#39;</span><span class="p">)</span>
                <span class="n">variance</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="k">if</span> <span class="n">share</span> <span class="o">==</span> <span class="mf">0.0</span> <span class="ow">and</span> <span class="n">batch_size</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Either supply batch_size or set share to positive number&#39;</span><span class="p">)</span>

        <span class="c1"># pos of batch-items that correspond to crops</span>
        <span class="n">crops_indices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int16</span><span class="p">)</span>

        <span class="c1"># infer the number of cancerous nodules and the size of batch</span>
        <span class="n">batch_size</span> <span class="o">=</span> <span class="n">batch_size</span> <span class="k">if</span> <span class="n">batch_size</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="mf">1.0</span> <span class="o">/</span> <span class="n">share</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_nodules</span>
        <span class="n">cancer_n</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">share</span> <span class="o">*</span> <span class="n">batch_size</span><span class="p">)</span>
        <span class="n">batch_size</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">batch_size</span><span class="p">)</span>
        <span class="n">cancer_n</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_nodules</span> <span class="k">if</span> <span class="n">cancer_n</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_nodules</span> <span class="k">else</span> <span class="n">cancer_n</span>

        <span class="k">if</span> <span class="n">batch_size</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">SkipBatchException</span><span class="p">(</span><span class="s1">&#39;Batch of zero size cannot be passed further through the workflow&#39;</span><span class="p">)</span>

        <span class="c1"># choose cancerous nodules&#39; starting positions</span>
        <span class="n">nodule_size</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">nodule_size</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_nodules</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">cancer_nodules</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># adjust cancer nodules&#39; starting positions s.t. nodules fit into</span>
            <span class="c1"># scan-boxes</span>
            <span class="n">cancer_nodules</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_fit_into_bounds</span><span class="p">(</span>
                <span class="n">nodule_size</span><span class="p">,</span> <span class="n">variance</span><span class="o">=</span><span class="n">variance</span><span class="p">)</span>

            <span class="c1"># randomly select needed number of cancer nodules (their starting</span>
            <span class="c1"># positions)</span>
            <span class="n">sample_indices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">choice</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">num_nodules</span><span class="p">),</span>
                                              <span class="n">size</span><span class="o">=</span><span class="n">cancer_n</span><span class="p">,</span> <span class="n">replace</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
            <span class="n">cancer_nodules</span> <span class="o">=</span> <span class="n">cancer_nodules</span><span class="p">[</span><span class="n">sample_indices</span><span class="p">,</span> <span class="p">:]</span>

            <span class="c1"># store scans-indices for chosen crops</span>
            <span class="n">cancerous_indices</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">nodules</span><span class="o">.</span><span class="n">patient_pos</span><span class="p">[</span><span class="n">sample_indices</span><span class="p">]</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
            <span class="n">crops_indices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">([</span><span class="n">crops_indices</span><span class="p">,</span> <span class="n">cancerous_indices</span><span class="p">])</span>

        <span class="n">nodules_st_pos</span> <span class="o">=</span> <span class="n">cancer_nodules</span>

        <span class="c1"># if non-cancerous nodules are needed, add random starting pos</span>
        <span class="k">if</span> <span class="n">batch_size</span> <span class="o">-</span> <span class="n">cancer_n</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="c1"># sample starting positions for (most-likely) non-cancerous crops</span>
            <span class="n">random_nodules</span><span class="p">,</span> <span class="n">random_indices</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sample_random_nodules</span><span class="p">(</span><span class="n">batch_size</span> <span class="o">-</span> <span class="n">cancer_n</span><span class="p">,</span>
                                                                        <span class="n">nodule_size</span><span class="p">,</span> <span class="n">histo</span><span class="o">=</span><span class="n">histo</span><span class="p">)</span>

            <span class="c1"># concat non-cancerous and cancerous crops&#39; starting positions</span>
            <span class="n">nodules_st_pos</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">([</span><span class="n">nodules_st_pos</span><span class="p">,</span> <span class="n">random_nodules</span><span class="p">])</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span>
                <span class="n">np</span><span class="o">.</span><span class="n">int</span><span class="p">)</span>  <span class="c1"># pylint: disable=no-member</span>

            <span class="c1"># store scan-indices for randomly chose crops</span>
            <span class="n">crops_indices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">([</span><span class="n">crops_indices</span><span class="p">,</span> <span class="n">random_indices</span><span class="p">])</span>

        <span class="c1"># obtain nodules&#39; scans by cropping from self.images</span>
        <span class="n">images</span> <span class="o">=</span> <span class="n">get_nodules_numba</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">images</span><span class="p">,</span> <span class="n">nodules_st_pos</span><span class="p">,</span> <span class="n">nodule_size</span><span class="p">)</span>

        <span class="c1"># if mask_shape not None, compute scaled mask for the whole batch</span>
        <span class="c1"># scale also nodules&#39; starting positions and nodules&#39; shapes</span>
        <span class="k">if</span> <span class="n">mask_shape</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">scale_factor</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">mask_shape</span><span class="p">)</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">nodule_size</span><span class="p">)</span>
            <span class="n">batch_mask_shape</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">rint</span><span class="p">(</span>
                <span class="n">scale_factor</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">images_shape</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:])</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">int</span><span class="p">)</span>
            <span class="n">batch_mask</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">fetch_mask</span><span class="p">(</span><span class="n">batch_mask_shape</span><span class="p">)</span>
            <span class="n">nodules_st_pos</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">rint</span><span class="p">(</span>
                <span class="n">scale_factor</span> <span class="o">*</span> <span class="n">nodules_st_pos</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">int</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">batch_mask</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">masks</span>
            <span class="n">mask_shape</span> <span class="o">=</span> <span class="n">nodule_size</span>

        <span class="c1"># crop nodules&#39; masks</span>
        <span class="n">masks</span> <span class="o">=</span> <span class="n">get_nodules_numba</span><span class="p">(</span><span class="n">batch_mask</span><span class="p">,</span> <span class="n">nodules_st_pos</span><span class="p">,</span> <span class="n">mask_shape</span><span class="p">)</span>

        <span class="c1"># build nodules&#39; batch</span>
        <span class="n">bounds</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">batch_size</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">nodule_size</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">crops_spacing</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">spacing</span><span class="p">[</span><span class="n">crops_indices</span><span class="p">]</span>
        <span class="n">offset</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">batch_size</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span>
        <span class="n">offset</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">lower_bounds</span><span class="p">[</span><span class="n">crops_indices</span><span class="p">]</span>
        <span class="n">crops_origin</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">origin</span><span class="p">[</span><span class="n">crops_indices</span><span class="p">]</span> <span class="o">+</span> <span class="n">crops_spacing</span> <span class="o">*</span> <span class="p">(</span><span class="n">nodules_st_pos</span> <span class="o">-</span> <span class="n">offset</span><span class="p">)</span>
        <span class="n">names_gen</span> <span class="o">=</span> <span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">indices</span><span class="p">[</span><span class="n">crops_indices</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">make_indices</span><span class="p">(</span><span class="n">batch_size</span><span class="p">))</span>
        <span class="n">ix_batch</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;_&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="n">prefix</span><span class="p">,</span> <span class="n">random_str</span><span class="p">])</span> <span class="k">for</span> <span class="n">prefix</span><span class="p">,</span> <span class="n">random_str</span> <span class="ow">in</span> <span class="n">names_gen</span><span class="p">]</span>
        <span class="n">nodules_batch</span> <span class="o">=</span> <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)(</span><span class="n">DatasetIndex</span><span class="p">(</span><span class="n">ix_batch</span><span class="p">))</span>
        <span class="n">nodules_batch</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">source</span><span class="o">=</span><span class="n">images</span><span class="p">,</span> <span class="n">fmt</span><span class="o">=</span><span class="s1">&#39;ndarray&#39;</span><span class="p">,</span> <span class="n">bounds</span><span class="o">=</span><span class="n">bounds</span><span class="p">,</span> <span class="n">spacing</span><span class="o">=</span><span class="n">crops_spacing</span><span class="p">,</span> <span class="n">origin</span><span class="o">=</span><span class="n">crops_origin</span><span class="p">)</span>

        <span class="c1"># set masks</span>
        <span class="n">nodules_batch</span><span class="o">.</span><span class="n">masks</span> <span class="o">=</span> <span class="n">masks</span>

        <span class="c1"># set nodules info in nodules&#39; batch</span>
        <span class="n">nodules_records</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">nodules</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">nodules</span><span class="o">.</span><span class="n">patient_pos</span> <span class="o">==</span> <span class="n">crop_pos</span><span class="p">]</span> <span class="k">for</span> <span class="n">crop_pos</span> <span class="ow">in</span> <span class="n">crops_indices</span><span class="p">]</span>
        <span class="n">new_patient_pos</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">records</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">nodules_records</span><span class="p">):</span>
            <span class="n">new_patient_pos</span> <span class="o">+=</span> <span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">records</span><span class="p">)</span>
        <span class="n">new_patient_pos</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">new_patient_pos</span><span class="p">)</span>
        <span class="n">nodules_records</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span><span class="n">nodules_records</span><span class="p">)</span>
        <span class="n">nodules_records</span> <span class="o">=</span> <span class="n">nodules_records</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">recarray</span><span class="p">)</span>
        <span class="n">nodules_records</span><span class="o">.</span><span class="n">patient_pos</span> <span class="o">=</span> <span class="n">new_patient_pos</span>
        <span class="n">nodules_batch</span><span class="o">.</span><span class="n">fetch_nodules_info</span><span class="p">(</span><span class="n">nodules_records</span><span class="o">=</span><span class="n">nodules_records</span><span class="p">)</span>

        <span class="c1"># leave out nodules with zero-intersection with crops&#39; boxes</span>
        <span class="n">nodules_batch</span><span class="o">.</span><span class="n">_filter_nodules_info</span><span class="p">()</span>                                                     <span class="c1"># pylint: disable=protected-access</span>

        <span class="k">return</span> <span class="n">nodules_batch</span></div>

    <span class="nd">@action</span>
<div class="viewcode-block" id="CTImagesMaskedBatch.sample_dump"><a class="viewcode-back" href="../../../temp_rst/lung_cancer.preprocessing.html#lung_cancer.preprocessing.ct_masked_batch.CTImagesMaskedBatch.sample_dump">[docs]</a>    <span class="k">def</span> <span class="nf">sample_dump</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dst</span><span class="p">,</span> <span class="n">n_iters</span><span class="p">,</span> <span class="n">nodule_size</span><span class="o">=</span><span class="p">(</span><span class="mi">32</span><span class="p">,</span> <span class="mi">64</span><span class="p">,</span> <span class="mi">64</span><span class="p">),</span> <span class="n">batch_size</span><span class="o">=</span><span class="mi">20</span><span class="p">,</span> <span class="n">share</span><span class="o">=</span><span class="mf">0.8</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Perform sample_nodules and dump on the same batch n_iters times.</span>

<span class="sd">        Can be used for fast creation of large datasets of cancerous/non-cancerous crops.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        dst :         str</span>
<span class="sd">                      folder to dump nodules in.</span>
<span class="sd">        n_iters :     int</span>
<span class="sd">                      number of iterations to be performed.</span>
<span class="sd">        nodule_size : tuple or list</span>
<span class="sd">                      shape of sampled nodules.</span>
<span class="sd">        batch_size :  int or None</span>
<span class="sd">                      size of generated batches.</span>
<span class="sd">        share :       float</span>
<span class="sd">                      share of cancer nodules. See docstring of sample_nodules for more info</span>
<span class="sd">                      about possible combinations of parameters share and batch_size.</span>
<span class="sd">        **kwargs :    dict</span>
<span class="sd">                      additional arguments supplied into sample_nodules. See docstring</span>
<span class="sd">                      of sample_nodules for more info.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_iters</span><span class="p">):</span>
            <span class="n">nodules</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sample_nodules</span><span class="p">(</span><span class="n">batch_size</span><span class="o">=</span><span class="n">batch_size</span><span class="p">,</span> <span class="n">nodule_size</span><span class="o">=</span><span class="n">nodule_size</span><span class="p">,</span> <span class="n">share</span><span class="o">=</span><span class="n">share</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
            <span class="n">nodules</span> <span class="o">=</span> <span class="n">nodules</span><span class="o">.</span><span class="n">dump</span><span class="p">(</span><span class="n">dst</span><span class="o">=</span><span class="n">dst</span><span class="p">)</span>

        <span class="k">return</span> <span class="bp">self</span></div>

    <span class="nd">@action</span>
<div class="viewcode-block" id="CTImagesMaskedBatch.update_nodules_histo"><a class="viewcode-back" href="../../../temp_rst/lung_cancer.preprocessing.html#lung_cancer.preprocessing.ct_masked_batch.CTImagesMaskedBatch.update_nodules_histo">[docs]</a>    <span class="k">def</span> <span class="nf">update_nodules_histo</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">histo</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Update histogram of nodules&#39; locations using nodules locations from batch.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        histo : list</span>
<span class="sd">                list(np.histogram()), used for sampling cancerous locations.</span>


<span class="sd">        Note</span>
<span class="sd">        ----</span>
<span class="sd">        Execute action only after .fetch_nodules_info().</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># infer bins&#39; bounds from histo</span>
        <span class="n">bins</span> <span class="o">=</span> <span class="n">histo</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>

        <span class="c1"># get cancer_nodules&#39; centers in voxel coords</span>
        <span class="n">center_pix</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nodules</span><span class="o">.</span><span class="n">nodule_center</span> <span class="o">-</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">nodules</span><span class="o">.</span><span class="n">origin</span><span class="p">)</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">nodules</span><span class="o">.</span><span class="n">spacing</span>

        <span class="c1"># update bins of histo</span>
        <span class="n">histo_delta</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">histogramdd</span><span class="p">(</span><span class="n">center_pix</span><span class="p">,</span> <span class="n">bins</span><span class="o">=</span><span class="n">bins</span><span class="p">)</span>
        <span class="n">histo</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+=</span> <span class="n">histo_delta</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

        <span class="k">return</span> <span class="bp">self</span></div>

<div class="viewcode-block" id="CTImagesMaskedBatch.get_axial_slice"><a class="viewcode-back" href="../../../temp_rst/lung_cancer.preprocessing.html#lung_cancer.preprocessing.ct_masked_batch.CTImagesMaskedBatch.get_axial_slice">[docs]</a>    <span class="k">def</span> <span class="nf">get_axial_slice</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">patient_pos</span><span class="p">,</span> <span class="n">height</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Get tuple of `images` slice and `masks` slice by patient and slice position.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        patient_pos : int</span>
<span class="sd">                      patient position in the batch</span>
<span class="sd">        height :      float</span>
<span class="sd">                      number of slice (z-axis), scaled to [0:1]</span>
<span class="sd">                      used to get slice with position:</span>
<span class="sd">                      int(height * number_of slices_for_patient) from</span>
<span class="sd">                      patient&#39;s scan and mask.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        tuple</span>
<span class="sd">             (images_slice,masks_slice) by patient_pos and number of slice</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">margin</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">height</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">patient_pos</span><span class="p">,</span> <span class="s1">&#39;images&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">masks</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">patch</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">patient_pos</span><span class="p">,</span> <span class="s1">&#39;images&#39;</span><span class="p">)[</span><span class="n">margin</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:],</span>
                     <span class="bp">self</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">patient_pos</span><span class="p">,</span> <span class="s1">&#39;masks&#39;</span><span class="p">)[</span><span class="n">margin</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">patch</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">patient_pos</span><span class="p">,</span> <span class="s1">&#39;images&#39;</span><span class="p">)[</span><span class="n">margin</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:],</span> <span class="kc">None</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">patch</span></div>

    <span class="k">def</span> <span class="nf">_refresh_nodules_info</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">images_loaded</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Refresh self.nodules attributes [spacing, origin, img_size, bias].</span>

<span class="sd">        This method is called to update [spacing, origin, img_size, bias]</span>
<span class="sd">        attributes of self.nodules because batch&#39;s inner data has changed,</span>
<span class="sd">        e.g. after resize.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        images_loaded : bool</span>
<span class="sd">                        if True, assumes that `_bounds` attribute is computed,</span>
<span class="sd">                        i.e. either `masks` and/or `images` are loaded.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">images_loaded</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">nodules</span><span class="o">.</span><span class="n">offset</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">lower_bounds</span><span class="p">[</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">nodules</span><span class="o">.</span><span class="n">patient_pos</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">nodules</span><span class="o">.</span><span class="n">img_size</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">images_shape</span><span class="p">[</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">nodules</span><span class="o">.</span><span class="n">patient_pos</span><span class="p">,</span> <span class="p">:]</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">nodules</span><span class="o">.</span><span class="n">spacing</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">spacing</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">nodules</span><span class="o">.</span><span class="n">patient_pos</span><span class="p">,</span> <span class="p">:]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nodules</span><span class="o">.</span><span class="n">origin</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">origin</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">nodules</span><span class="o">.</span><span class="n">patient_pos</span><span class="p">,</span> <span class="p">:]</span>

    <span class="k">def</span> <span class="nf">_filter_nodules_info</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Filter record-array self.nodules s.t. only records about cancerous nodules</span>
<span class="sd">        that have non-zero intersection with scan-boxes be present.</span>

<span class="sd">        Note</span>
<span class="sd">        ----</span>
<span class="sd">        can be called only after execution of fetch_nodules_info and _refresh_nodules_info</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># nodules start and trailing pixel-coords</span>
        <span class="n">center_pix</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nodules</span><span class="o">.</span><span class="n">nodule_center</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">nodules</span><span class="o">.</span><span class="n">origin</span><span class="p">)</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">nodules</span><span class="o">.</span><span class="n">spacing</span>
        <span class="n">start_pix</span> <span class="o">=</span> <span class="n">center_pix</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">rint</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nodules</span><span class="o">.</span><span class="n">nodule_size</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">nodules</span><span class="o">.</span><span class="n">spacing</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span>
        <span class="n">start_pix</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">rint</span><span class="p">(</span><span class="n">start_pix</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">int</span><span class="p">)</span>
        <span class="n">end_pix</span> <span class="o">=</span> <span class="n">start_pix</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">rint</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nodules</span><span class="o">.</span><span class="n">nodule_size</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">nodules</span><span class="o">.</span><span class="n">spacing</span><span class="p">)</span>

        <span class="c1"># find nodules with no intersection with scan-boxes</span>
        <span class="n">nods_images_shape</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">images_shape</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">nodules</span><span class="o">.</span><span class="n">patient_pos</span><span class="p">]</span>
        <span class="n">start_mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">start_pix</span> <span class="o">&gt;=</span> <span class="n">nods_images_shape</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">end_mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">end_pix</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">zero_mask</span> <span class="o">=</span> <span class="n">start_mask</span> <span class="o">|</span> <span class="n">end_mask</span>

        <span class="c1"># filter out such nodules</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nodules</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">nodules</span><span class="p">[</span><span class="o">~</span><span class="n">zero_mask</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">_rescale_spacing</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Rescale spacing values and call _refresh_nodules_info().</span>

<span class="sd">        Method is called after any operation that changes shape of inner data.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">nodules</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_refresh_nodules_info</span><span class="p">()</span>
        <span class="k">return</span> <span class="bp">self</span>

    <span class="k">def</span> <span class="nf">_post_mask</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">list_of_arrs</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Concatenate outputs of different workers and put the result in `masks`</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        list_of_arrs : list</span>
<span class="sd">                       list of ndarrays of patients&#39; masks.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">any_action_failed</span><span class="p">(</span><span class="n">list_of_arrs</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Failed while parallelizing&quot;</span><span class="p">)</span>

        <span class="n">new_masks</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span><span class="n">list_of_arrs</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">masks</span> <span class="o">=</span> <span class="n">new_masks</span>

        <span class="k">return</span> <span class="bp">self</span>

    <span class="k">def</span> <span class="nf">_init_load_blosc</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Init-func for load from blosc.</span>

<span class="sd">        Fills images/masks-components with zeroes if the components are to be updated.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        **kwargs</span>
<span class="sd">                src :     str, list or tuple</span>
<span class="sd">                          iterable of components names that need to be loaded</span>
<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        list</span>
<span class="sd">            list of ids of batch-items, i.e. series ids or patient ids.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># read shapes, fill the components with zeroes if masks, images need to</span>
        <span class="c1"># be updated</span>
        <span class="k">if</span> <span class="s1">&#39;masks&#39;</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;src&#39;</span><span class="p">]</span> <span class="ow">or</span> <span class="s1">&#39;images&#39;</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;src&#39;</span><span class="p">]:</span>
            <span class="n">slice_shape</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_preload_shapes</span><span class="p">()</span>
            <span class="n">skysc_shape</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_bounds</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="p">)</span> <span class="o">+</span> <span class="n">slice_shape</span>

            <span class="c1"># fill needed comps with zeroes</span>
            <span class="k">for</span> <span class="n">source</span> <span class="ow">in</span> <span class="p">{</span><span class="s1">&#39;images&#39;</span><span class="p">,</span> <span class="s1">&#39;masks&#39;</span><span class="p">}</span> <span class="o">&amp;</span> <span class="nb">set</span><span class="p">(</span><span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;src&#39;</span><span class="p">]):</span>
                <span class="nb">setattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">source</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">skysc_shape</span><span class="p">))</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">indices</span>

    <span class="k">def</span> <span class="nf">_post_rebuild</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">all_outputs</span><span class="p">,</span> <span class="n">new_batch</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Gather outputs of different workers, rebuild `images` and `masks`.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        all_outputs : list</span>
<span class="sd">                      list of outputs. Each item is given by tuple</span>
<span class="sd">        new_batch :   bool</span>
<span class="sd">                      if True, returns new batch with data agregated</span>
<span class="sd">                      from all_ouputs. if False, changes self.</span>
<span class="sd">        **kwargs</span>
<span class="sd">                shape :   list, tuple or ndarray</span>
<span class="sd">                          (z,y,x); shape of every image in image component after action is performed.</span>
<span class="sd">                spacing : list, tuple or ndarray</span>
<span class="sd">                          if supplied, assume that unify_spacing is performed</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># TODO: process errors</span>
        <span class="n">batch</span> <span class="o">=</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">_post_rebuild</span><span class="p">(</span><span class="n">all_outputs</span><span class="p">,</span> <span class="n">new_batch</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="n">batch</span><span class="o">.</span><span class="n">nodules</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">nodules</span>
        <span class="n">batch</span><span class="o">.</span><span class="n">_rescale_spacing</span><span class="p">()</span>  <span class="c1"># pylint: disable=protected-access</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">masks</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">batch</span><span class="o">.</span><span class="n">create_mask</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">batch</span>

    <span class="nd">@action</span>
<div class="viewcode-block" id="CTImagesMaskedBatch.make_xip"><a class="viewcode-back" href="../../../temp_rst/lung_cancer.preprocessing.html#lung_cancer.preprocessing.ct_masked_batch.CTImagesMaskedBatch.make_xip">[docs]</a>    <span class="k">def</span> <span class="nf">make_xip</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">step</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">depth</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="n">func</span><span class="o">=</span><span class="s1">&#39;max&#39;</span><span class="p">,</span>
                 <span class="n">projection</span><span class="o">=</span><span class="s1">&#39;axial&#39;</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Make intensity projection (maximum, minimum, average) and corresponding masks.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        step :       int</span>
<span class="sd">                     stride-step along axe, to apply the func.</span>
<span class="sd">        depth :      int</span>
<span class="sd">                     depth of slices (aka `kernel`) along axe made on each step for computing.</span>
<span class="sd">        func :       str</span>
<span class="sd">                     Possible values are &#39;max&#39;, &#39;min&#39; and &#39;avg&#39;.</span>
<span class="sd">        projection : str</span>
<span class="sd">                     Possible values: &#39;axial&#39;, &#39;coroanal&#39;, &#39;sagital&#39;.</span>
<span class="sd">                     In case of &#39;coronal&#39; and &#39;sagital&#39; projections tensor</span>
<span class="sd">                     will be transposed from [z,y,x] to [x, z, y] and [y, z, x].</span>
<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        batch</span>
<span class="sd">             Resulting batch, where `images` are xips and corresponding `masks`.</span>


<span class="sd">        Note</span>
<span class="sd">        ----</span>
<span class="sd">        Method changes nodules sizes&#39; and creates new `masks` that corresponds</span>
<span class="sd">        to data after xip.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">batch</span> <span class="o">=</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">make_xip</span><span class="p">(</span><span class="n">step</span><span class="o">=</span><span class="n">step</span><span class="p">,</span> <span class="n">depth</span><span class="o">=</span><span class="n">depth</span><span class="p">,</span> <span class="n">func</span><span class="o">=</span><span class="n">func</span><span class="p">,</span>
                                 <span class="n">projection</span><span class="o">=</span><span class="n">projection</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

        <span class="n">batch</span><span class="o">.</span><span class="n">nodules</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">nodules</span>
        <span class="k">if</span> <span class="n">projection</span> <span class="o">==</span> <span class="s1">&#39;axial&#39;</span><span class="p">:</span>
            <span class="n">_projection</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">elif</span> <span class="n">projection</span> <span class="o">==</span> <span class="s1">&#39;coronal&#39;</span><span class="p">:</span>
            <span class="n">_projection</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="k">elif</span> <span class="n">projection</span> <span class="o">==</span> <span class="s1">&#39;sagital&#39;</span><span class="p">:</span>
            <span class="n">_projection</span> <span class="o">=</span> <span class="mi">2</span>
        <span class="n">batch</span><span class="o">.</span><span class="n">nodules</span><span class="o">.</span><span class="n">nodule_size</span><span class="p">[:,</span> <span class="n">_projection</span><span class="p">]</span> <span class="o">+=</span> <span class="p">(</span><span class="n">depth</span>
                                                      <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">nodules</span><span class="o">.</span><span class="n">spacing</span><span class="p">[:,</span> <span class="n">_projection</span><span class="p">])</span>  <span class="c1"># pylint: disable=unsubscriptable-object</span>
        <span class="n">batch</span><span class="o">.</span><span class="n">spacing</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">rescale</span><span class="p">(</span><span class="n">batch</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
        <span class="n">batch</span><span class="o">.</span><span class="n">_rescale_spacing</span><span class="p">()</span>   <span class="c1"># pylint: disable=protected-access</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">masks</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">batch</span><span class="o">.</span><span class="n">create_mask</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">batch</span></div>

    <span class="nd">@action</span>
<div class="viewcode-block" id="CTImagesMaskedBatch.central_crop"><a class="viewcode-back" href="../../../temp_rst/lung_cancer.preprocessing.html#lung_cancer.preprocessing.ct_masked_batch.CTImagesMaskedBatch.central_crop">[docs]</a>    <span class="k">def</span> <span class="nf">central_crop</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">crop_size</span><span class="p">,</span> <span class="n">crop_mask</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Make crop of crop_size from center of images.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        crop_size : tuple</span>

<span class="sd">        #TODO: this method should be rewritten with the use of</span>
<span class="sd">        inheritance;</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">crop_size</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">crop_size</span><span class="p">)</span>
        <span class="n">img_shapes</span> <span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="s1">&#39;images&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
                      <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">))]</span>
        <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">shape</span> <span class="o">&lt;</span> <span class="n">crop_size</span><span class="p">)</span> <span class="k">for</span> <span class="n">shape</span> <span class="ow">in</span> <span class="n">img_shapes</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;Crop size must be smaller than size of inner 3D images&quot;</span><span class="p">)</span>

        <span class="n">cropped_images</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">cropped_masks</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">)):</span>
            <span class="n">image</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="s1">&#39;images&#39;</span><span class="p">)</span>
            <span class="n">cropped_images</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">make_central_crop</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="n">crop_size</span><span class="p">))</span>

            <span class="k">if</span> <span class="n">crop_mask</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">masks</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">mask</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="s1">&#39;masks&#39;</span><span class="p">)</span>
                <span class="n">cropped_masks</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">make_central_crop</span><span class="p">(</span><span class="n">mask</span><span class="p">,</span> <span class="n">crop_size</span><span class="p">))</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_bounds</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cumsum</span><span class="p">([</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="p">[</span><span class="n">crop_size</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">images</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span><span class="n">cropped_images</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">crop_mask</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">masks</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">masks</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span><span class="n">cropped_masks</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span></div>

<div class="viewcode-block" id="CTImagesMaskedBatch.flip"><a class="viewcode-back" href="../../../temp_rst/lung_cancer.preprocessing.html#lung_cancer.preprocessing.ct_masked_batch.CTImagesMaskedBatch.flip">[docs]</a>    <span class="k">def</span> <span class="nf">flip</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Invert the order of slices for each patient</span>

<span class="sd">        Example</span>
<span class="sd">        -------</span>
<span class="sd">        &gt;&gt;&gt; batch = batch.flip()</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s2">&quot;There is no implementation of flip method for class &quot;</span> <span class="o">+</span>
                       <span class="s2">&quot;CTIMagesMaskedBatch. Nothing happened&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span></div>

    <span class="nd">@action</span>
<div class="viewcode-block" id="CTImagesMaskedBatch.binarize_mask"><a class="viewcode-back" href="../../../temp_rst/lung_cancer.preprocessing.html#lung_cancer.preprocessing.ct_masked_batch.CTImagesMaskedBatch.binarize_mask">[docs]</a>    <span class="k">def</span> <span class="nf">binarize_mask</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">threshold</span><span class="o">=</span><span class="mf">0.35</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Binarize masks by threshold.</span>

<span class="sd">        Args:</span>
<span class="sd">        - threshold: float, threshold for masks binarization;</span>

<span class="sd">        Returns:</span>
<span class="sd">        - self, source CTImagesMaskedBatch with binarized masks.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">masks</span> <span class="o">*=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">masks</span> <span class="o">&gt;</span> <span class="n">threshold</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span></div>

    <span class="nd">@action</span>
<div class="viewcode-block" id="CTImagesMaskedBatch.predict_on_scan"><a class="viewcode-back" href="../../../temp_rst/lung_cancer.preprocessing.html#lung_cancer.preprocessing.ct_masked_batch.CTImagesMaskedBatch.predict_on_scan">[docs]</a>    <span class="k">def</span> <span class="nf">predict_on_scan</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">model_name</span><span class="p">,</span> <span class="n">strides</span><span class="o">=</span><span class="p">(</span><span class="mi">16</span><span class="p">,</span> <span class="mi">32</span><span class="p">,</span> <span class="mi">32</span><span class="p">),</span> <span class="n">crop_shape</span><span class="o">=</span><span class="p">(</span><span class="mi">32</span><span class="p">,</span> <span class="mi">64</span><span class="p">,</span> <span class="mi">64</span><span class="p">),</span>
                        <span class="n">batch_size</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span> <span class="n">y_component</span><span class="o">=</span><span class="s1">&#39;labels&#39;</span><span class="p">,</span> <span class="n">dim_ordering</span><span class="o">=</span><span class="s1">&#39;channels_last&#39;</span><span class="p">,</span>
                        <span class="n">show_progress</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Get predictions of the model on data contained in batch.</span>

<span class="sd">        Transforms scan data into patches of shape CROP_SHAPE and then feed</span>
<span class="sd">        this patches sequentially into model with name specified by</span>
<span class="sd">        argument &#39;model_name&#39;; after that loads predicted masks or probabilities</span>
<span class="sd">        into &#39;masks&#39; component of the current batch and returns it.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        model_name : str</span>
<span class="sd">            name of model that will be used for predictions.</span>
<span class="sd">        strides : tuple(int, int, int)</span>
<span class="sd">            strides for patching operation</span>
<span class="sd">        batch_size : int</span>
<span class="sd">            number of patches to feed in model in one iteration.</span>
<span class="sd">        y_component: str</span>
<span class="sd">            name of y component, can be &#39;masks&#39; or labels.</span>
<span class="sd">        dim_ordering: str</span>
<span class="sd">            dimension ordering, can be &#39;channels_first&#39; or &#39;channels_last&#39;.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        CTImagesMaskedBatch</span>
<span class="sd">            self(source batch).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">_model</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_model_by_name</span><span class="p">(</span><span class="n">model_name</span><span class="p">)</span>

        <span class="n">patches_arr</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_patches</span><span class="p">(</span><span class="n">patch_shape</span><span class="o">=</span><span class="n">crop_shape</span><span class="p">,</span>
                                       <span class="n">stride</span><span class="o">=</span><span class="n">strides</span><span class="p">,</span>
                                       <span class="n">padding</span><span class="o">=</span><span class="s1">&#39;reflect&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">dim_ordering</span> <span class="o">==</span> <span class="s1">&#39;channels_first&#39;</span><span class="p">:</span>
            <span class="n">patches_arr</span> <span class="o">=</span> <span class="n">patches_arr</span><span class="p">[:,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">,</span> <span class="o">...</span><span class="p">]</span>
        <span class="k">elif</span> <span class="n">dim_ordering</span> <span class="o">==</span> <span class="s1">&#39;channels_last&#39;</span><span class="p">:</span>
            <span class="n">patches_arr</span> <span class="o">=</span> <span class="n">patches_arr</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span>

        <span class="n">predictions</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">iterations</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">patches_arr</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">batch_size</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">show_progress</span><span class="p">:</span>
            <span class="n">iterations</span> <span class="o">=</span> <span class="n">tqdm_notebook</span><span class="p">(</span><span class="n">iterations</span><span class="p">)</span>  <span class="c1"># pylint: disable=redefined-variable-type</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">iterations</span><span class="p">:</span>
            <span class="n">current_prediction</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">_model</span><span class="o">.</span><span class="n">predict</span><span class="p">(</span><span class="n">patches_arr</span><span class="p">[</span><span class="n">i</span><span class="p">:</span> <span class="n">i</span> <span class="o">+</span> <span class="n">batch_size</span><span class="p">,</span> <span class="o">...</span><span class="p">]))</span>

            <span class="k">if</span> <span class="n">y_component</span> <span class="o">==</span> <span class="s1">&#39;labels&#39;</span><span class="p">:</span>
                <span class="n">current_prediction</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">stack</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="n">crop_shape</span><span class="p">))</span> <span class="o">*</span> <span class="n">prob</span>
                                               <span class="k">for</span> <span class="n">prob</span> <span class="ow">in</span> <span class="n">current_prediction</span><span class="o">.</span><span class="n">ravel</span><span class="p">()])</span>

            <span class="k">if</span> <span class="n">y_component</span> <span class="o">==</span> <span class="s1">&#39;regression&#39;</span><span class="p">:</span>
                <span class="n">masks_patch</span> <span class="o">=</span> <span class="n">create_mask_reg</span><span class="p">(</span><span class="n">current_prediction</span><span class="p">[:,</span> <span class="p">:</span><span class="mi">3</span><span class="p">],</span>
                                              <span class="n">current_prediction</span><span class="p">[:,</span> <span class="mi">3</span><span class="p">:</span><span class="mi">6</span><span class="p">],</span>
                                              <span class="n">current_prediction</span><span class="p">[:,</span> <span class="mi">6</span><span class="p">],</span>
                                              <span class="n">crop_shape</span><span class="p">,</span> <span class="mf">0.01</span><span class="p">)</span>

                <span class="n">current_prediction</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">masks_patch</span><span class="p">)</span>
            <span class="n">predictions</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">current_prediction</span><span class="p">)</span>

        <span class="n">patches_mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span><span class="n">predictions</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">load_from_patches</span><span class="p">(</span><span class="n">patches_mask</span><span class="p">,</span> <span class="n">stride</span><span class="o">=</span><span class="n">strides</span><span class="p">,</span>
                               <span class="n">scan_shape</span><span class="o">=</span><span class="nb">tuple</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">images_shape</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:]),</span>
                               <span class="n">data_attr</span><span class="o">=</span><span class="s1">&#39;masks&#39;</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span></div></div>
</pre></div>

          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <form class="search" action="../../../search.html" method="get">
      <div><input type="text" name="q" /></div>
      <div><input type="submit" value="Go" /></div>
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="nav-item nav-item-0"><a href="../../../index.html">RadIO 0.1.0 documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="../../index.html" >Module code</a> &#187;</li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &#169; Copyright 2017, analysiscenter.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.5.6.
    </div>
  </body>
</html>